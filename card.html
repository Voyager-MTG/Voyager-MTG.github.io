<html>

<head>
	<title>Card</title>
	<link rel="icon" type="image/x-icon" href="/img/favicon.png">
	<link rel="stylesheet" href="/src/css/mana.css">
	<link rel="stylesheet" href="/src/css/header.css">
	<link rel="stylesheet" href="/src/css/theme.css">
	<link rel="stylesheet" href="/src/css/modal.css">
	<link rel="stylesheet" href="/src/css/deck-container.css">
	<link rel="stylesheet" href="/src/css/img-container.css">
	<link rel="stylesheet" href="/src/css/pages/card.css">
</head>

<body>
	<div class="header">
		<div class="search-grid">
			<a href="/"><img class="sg-logo" src="/img/banner.png"></a>
			<img class="sg-icon" src="/img/header/search.png">
			<input type="text" inputmode="search" placeholder="Search ..." name="search" id="search" spellcheck="false"
				autocomplete="off" autocorrect="off" spellcheck="false">
			<a href="/all-sets"><img src="/img/header/sets.png" class="sg-icon">Sets</a>
			<a href="/deckbuilder"><img src="/img/header/deck.png" class="sg-icon">Deckbuilder</a>
			<a onclick="randomCard()"><img src="/img/random.png" class="sg-icon">Random</a>
			<div class="community"><a href="/community" id="account-link"><img src="/img/header/community.png"
						class="sg-icon">Community<b>⮟</b></a>
				<div class="community-dropdown">
					<a href="/community?tab=users" class="community-dropdown-item"><img class="dropdown-icon"
							src="img/header/community.png">Users</a>
					<a href="/community?tab=decks" class="community-dropdown-item"><img class="dropdown-icon"
							src="img/header/deck.png">Decks</a>
					<a href="/community?tab=events" class="community-dropdown-item"><img class="dropdown-icon"
							src="img/swords.png">Events</a>
					<a href="/community?tab=cards" class="community-dropdown-item"><img class="dropdown-icon"
							src="img/header/sets.png">Cards</a>
				</div>
			</div>
			<a href="/settings" id="account-link"><img src="/img/header/settings.png" class="sg-icon"></a>
			<a href="/account" id="account-link"><img src="/img/header/account.png" class="sg-icon"></a>
		</div>
	</div>

	<input type="text" id="display" class="hidden" value="cards-and-text">
	<!-- here to make img-container-defs snippet work properly -->
	<div class="banner-container">
		<a class="set-banner" id="set-banner">
			<img class="set-logo" id="set-banner-logo">
			<div class="set-title text" id="set-banner-title"></div>
		</a>
	</div>

	<div class="grid-container" id="grid">
	</div>
	<img id="hover-card" class="hover-card">
	<div id="modal-container">
		<div id="modal-content" class="popout">
			<span class="close"
				onclick="document.getElementById('modal-container').style.display = 'none';">&times;</span>
		</div>
	</div>
	<script src="src/js/background.js"></script>
	<script>
		let card_list_arrayified = [];
		let specialchars = "";

		modal = document.getElementById("modal-container");
		window.onclick = function (event) {
			if (event.target == modal) {
				modal.style.display = 'none';
			}
		}

		document.addEventListener("DOMContentLoaded", async function () {
			await fetch('/lists/all-cards.json')
				.then(response => response.json())
				.then(json => {
					card_list = json;
				}).catch(error => console.error('Error:', error));

			await fetch('/resources/replacechars.txt')
				.then(response => response.text())
				.then(text => {
					specialchars = text;
				}).catch(error => console.error('Error:', error));

			card_list_arrayified = card_list.cards;

			await fetch('/lists/all-sets.json')
				.then(response => response.json())
				.then(json => {
					set_list = json;
				}).catch(error => console.error('Error:', error));

			await fetch('/resources/related-cards.json')
				.then(response => response.json())
				.then(json => {
					related_cards_json = json;
				}).catch(error => console.error('Error:', error));

			await fetch('/lists/banlist.json')
				.then(response => response.json())
				.then(json => {
					banlist = json;
				}).catch(error => console.error('Error:', error));

			const params = new URLSearchParams(window.location.search);

			const set = params.get('set');
			const num = params.get('num');
			const name = params.get('name');

			for (const c of card_list_arrayified) {
				if (c.card_name == name && c.set == set && c.number == num) {
					card = c;
					break;
				}
			}

			// const card_desc = card.type       + "\n" + 
			//                   card.rules_text + "\n" +
			// 				  card.pt

			// const card_stats = card;
			// const card_img = "https://voyager-mtg.github.io/sets/" + card_stats.set + "-files/img/" + card_stats.number + (card_stats.shape.includes("token") ? "t_" : "_") + card_stats.card_name + ((card_stats.shape.includes("double")) ? "_front" : "") + "." + card_stats.image_type;

			// document.getElementById("meta-card-name").setAttribute("content", name);
			// document.getElementById("meta-card-desc").setAttribute("content", card_desc);
			// document.getElementById("meta-card-url").setAttribute("content", window.location.href);
			// document.getElementById("meta-card-img").setAttribute("content", card_img);

			var link = document.querySelector("link[rel~='icon']");
			link.href = '/sets/' + set + '-files/icon.png';

			document.title = name;

			const banner = document.getElementById("set-banner");
			const banner_logo = document.getElementById("set-banner-logo");
			const banner_title = document.getElementById("set-banner-title");

			banner.href = '/sets/' + set;
			banner_logo.src = '/sets/' + set + '-files/icon.png';

			banner_title.innerHTML = getSetName(set);

			document.getElementById("grid").appendChild(gridifyCard(card, false, false));

			const related_cards = await fetchRelatedCards(card);

			other_printings = [];
			for (const c of card_list_arrayified) {
				if (c.card_name == card.card_name && c.type == card.type && !c.shape.includes("Token")) {
					other_printings.push(c);
				}
			}

			if (related_cards.length > 0) {
				const others = document.createElement("div");
				others.className = "related";
				others.id = "related-cards";
				others.innerText = "Related Cards: ";

				for (let i = 0; i < related_cards.length; i++) {
					let related_card;
					const related = related_cards[i];
					const setlink = document.createElement("a");
					setlink.innerText = related;

					setlink.onmouseover = function () { showCardHover(related) };
					setlink.onmousemove = function (event) { moveCardHover(event) };
					setlink.onmouseout = hideCardHover;

					for (const card_ of card_list_arrayified) {
						if (card_.card_name == related) {
							related_card = card_;
						}
					}

					const url = new URL('card', window.location.origin);
					const params = {
						set: related_card.set,
						num: related_card.number,
						name: related_card.card_name
					}
					for (const key in params) {
						url.searchParams.append(key, params[key]);
					}
					setlink.href = url;

					others.appendChild(setlink);

					if (i != related_cards.length - 1) {
						const dot = document.createElement("text");
						dot.innerText = " • ";
						others.appendChild(dot);
					}
				}

				const effect = document.getElementsByClassName("effect")[0];

				for (const card of related_cards) {
					if (effect.innerHTML.includes(`<b>${card}</b>`)) {
						effect.innerHTML = effect.innerHTML.replaceAll(/trace (it|this [^ ])'?s? skill/gs, function (_1) {
							return `<span class="card-hover" onmouseover="showCardHover('${card}')" onmousemove="moveCardHover(event)" onmouseout="hideCardHover()">${_1}</span>`;
						});
					}

					effect.innerHTML = effect.innerHTML.replaceAll(new RegExp(`${card}[^']`, "gs"), function (_1) {
						return `<span class="card-hover" onmouseover="showCardHover('${card}')" onmousemove="moveCardHover(event)" onmouseout="hideCardHover()">${card}</span>${_1.replace(card, "")}`;
					});
				};


				for (const token in related_cards_json.matches) {
					const match = related_cards_json.matches[token];
					effect.innerHTML = effect.innerHTML.replaceAll(new RegExp(match, "gs"), function (_1, _2) {
						return `<span class="card-hover" onmouseover="showCardHover('${token}')" onmousemove="moveCardHover(event)" onmouseout="hideCardHover()">${_1}</span>`;
					});
				}

				document.getElementById("card-text").appendChild(others);
				document.getElementById("related-cards").style.display = "block";
			}

			const printings = document.createElement("div");
			printings.className = "printings";
			printings.id = "other-printings";
			printings.innerText = "Printings: ";

			for (let i = 0; i < other_printings.length; i++) {
				const printing = other_printings[i];
				const setlink = document.createElement("a");
				setlink.innerText = getSetName(printing.set) + " (" + (rarityCode(printing.rarity)) + "#" + printing.number + ")";

				const url = new URL('card', window.location.origin);
				const params = {
					set: printing.set,
					num: printing.number,
					name: printing.card_name
				}
				for (const key in params) {
					url.searchParams.append(key, params[key]);
				}

				if (printing.set == card.set && printing.number == card.number) {
					setlink.className = "current-printing";
				} else {
					setlink.href = url;
				}

				setlink.onmousemove = function (event) { moveCardHover(event) };
				setlink.onmouseover = function () { showCardHover(printing.card_name, printing.set, printing.number) };
				setlink.onmouseout = hideCardHover;

				printings.appendChild(setlink);

				if (i != other_printings.length - 1) {
					const dot = document.createElement("text");
					dot.innerText = " • ";
					printings.appendChild(dot);
				}
			}

			document.getElementById("card-text").appendChild(printings);
			document.getElementById("other-printings").style.display = "block";

			const changes_html = await fetchCardChanges(card);

			const changes_container = document.createElement("div");
			changes_container.innerHTML = changes_html;

			const rulings_container = document.createElement("div");
			rulings_container.className = "rulings-container";

			const image_grid = document.getElementsByClassName("image-grid")[0];

			image_grid.appendChild(rulings_container);
			image_grid.appendChild(changes_container);
		});

		function isBannedCard(card_name) {
			return banlist.banned.includes(card_name);
		}


		function rarityCode(r) {
			switch (r) {
				case "common":
					return "C"
				case "uncommon":
					return "U"
				case "rare":
					return "R"
				case "mythic":
					return "M"
				case "masterpiece":
					return "MP"
				case "special":
					return "S"
			}
		}

		function showCardHover(card_name, set = false, num = false) {
			// console.log(set, num);
			for (const card_stats of card_list_arrayified) {
				if (card_stats.card_name == card_name && (!set || card_stats.set == set) && (!num || card_stats.number == num)) {
					console.log(card_stats, set, num);
					const src = "/sets/" + card_stats.set + "-files/img/" + card_stats.number + (card_stats.shape.includes("token") ? "t_" : "_") + card_stats.card_name + ((card_stats.shape.includes("double")) ? "_front" : "") + "." + card_stats.image_type;

					const hover_card = document.getElementById("hover-card");
					hover_card.style.display = "block";
					hover_card.src = src;
					return;
				}
			}
		}

		function moveCardHover(event) {
			document.getElementById("hover-card").style.left = event.pageX + "px";
			document.getElementById("hover-card").style.top = event.pageY - 262 + "px";
		}

		function hideCardHover() {
			document.getElementById("hover-card").style.display = "none";
		}

		function getSetName(code) {
			for (const set_stats of set_list.sets) {
				if (set_stats.set_code == code) {
					return set_stats.set_name;
				}
			}
		}

		async function fetchRelatedCards(card) {
			let related_cards = [];

			const token_matches = related_cards_json.matches;

			for (const token in token_matches) {
				const match = new RegExp(token_matches[token]);
				if (match.test(card.rules_text)) {
					related_cards.push(token.replaceAll("~", card.card_name));
				}
			}

			for (const name of card.rules_text.matchAll(/^(.*)(card|token)s? named (.*?) (into|,|with)/gs)) {
				for (const card_ of card_list_arrayified) {
					if (card_.card_name == name[3] && !related_cards.includes(name[3])) {
						related_cards.push(name[3]);
					}
				}
			}

			const skill_match = /trace (it|this [^ ])'?s? skill/g;
			if (card.rules_text.match(skill_match)) {
				for (const name of card.rules_text.matchAll(/\[b\](.*)\[\/b\]/gs)) {
					if (!related_cards.includes(name[1])) {
						related_cards.push(name[1]);
					}
				}
			}

			for (const tk of card_list_arrayified) {
				if (tk.shape == "token") {
					if (card.notes.includes(`!addtoken ${tk.card_name}` && !related_cards.includes(tk.card_name))) {
						related_cards.push(tk.card_name);
					}
					for (const name of tk.notes.matchAll(/!related (.*?)[\n;!]/gs)) {
						if (name[1] == card.card_name && !related_cards.includes(tk.card_name)) {
							related_cards.push(tk.card_name);
						}
					}
				}
			}

			return related_cards;
		}

		async function fetchCardChanges(card) {
			await fetch('/data/changelogs.json')
				.then(response => response.json())
				.then(json => {
					change_list = json;
				}).catch(error => console.error('Error:', error));

			let changes = [];

			for (const date in change_list) {
				const changelog = change_list[date];
				const card_match = new RegExp(`\\*\\*${RegExp.escape(card.card_name)}(\\'s)?\\*\\* (.*?)\\n`, "g");
				if (card_match.test(changelog)) {
					const match = changelog.match(card_match);
					changes.push([date, match[0].split("**")[2]]);
				}
			}

			let html = '<span class="changes-header text">Changes:</span><div class="card-changes text"><ul>';

			for (let change of changes) {
				change[1] = change[1].trim();
				html += "<li>" + change[0] + ": " + formatChange(change[1]) + "</li>";
			}

			html += "</ul></div>";

			return html;
		}

		function formatChange(change) {
			change = change.replaceAll(/<:mana([wubrgivxt0-9]+?):[0-9]+?>/g, function (_1, mana_type) {
				return symbolize("{" + mana_type + "}");
			})
			change = change[0].toUpperCase() + change.substring(1);

			return change;
		}

		function isDecimal(char) {
			return char >= '0' && char <= '9';
		}

		function tokenize(text) {
			let tokens = [];

			for (let i = 0; i < text.length; i++) {
				if (i < text.length - 1) {
					if (text[i + 1] == '/') {
						tokens.push(text.substring(i, i + 3));
						i = i + 2;
					}
					else if (isDecimal(text[i]) && isDecimal(text[i + 1])) {
						tokens.push(text.substring(i, i + 2));
						i = i + 1;
					}
					else {
						tokens.push(text[i]);
					}
				}
				else {
					tokens.push(text[i]);
				}
			}

			return tokens;
		}

		function symbolize(text) {
			//This isn't needed now that the { & } are put into the cost & text by the exporter
			//let tokens = tokenize(text);
			//let symText = "";
			//for (const token of tokens)
			//{
			//	symText = symText + "{" + token + "}";
			//}

			return formatTextHTML(text);
		}

		function formatTextHTML(str) {
			if (!str)
				return "";
			str = str.replace(/[{]([^}]+)[}]/g, function (matched, _1) {
				let letters = _1.toLowerCase()
				return `<span class="mana mana-cost ${isText(letters)} mana-` + letters + '"></span>';
			})
			return str;
		}

		function isText(l) {
			if (l.includes("v") || l.includes("e")) {
				return "popout";
			}
			return "";
		}

		function gridifyCard(card_stats, card_text = false, rotate_card = false, designer_notes = true) {
			card_stats = card;
			const card_name = card_stats.card_name;

			const textContainer = document.createElement("div");
			textContainer.className = "text-container";

			const grid = document.createElement("div");
			grid.className = "image-grid";

			grid.appendChild(buildImgContainer(card_stats, false, rotate_card));

			const text = document.createElement("div");
			text.className = "card-text popout";
			text.id = "card-text";

			const name_cost = document.createElement("div");
			name_cost.className = "name-cost";
			name_cost.innerHTML = card_stats.card_name + (card_stats.cost != "" ? '     ' + symbolize(card_stats.cost) : "");
			text.appendChild(name_cost);

			const type = document.createElement("div");
			type.className = "type";
			type.textContent = card_stats.type;
			text.appendChild(type);

			const effect = document.createElement("div");
			effect.className = "effect";
			let card_effects = "";
			if (card_stats.rules_text != "") {
				card_effects = [...card_stats.rules_text.split("\n"), (card_stats.flavor_text != "[i][/i]" ? "<hr class=\"ft-divider text-bg\"></div>" + card_stats.flavor_text : "")];
			}
			else {
				card_effects = card_stats.special_text.split("\n");
			}
			effect.innerHTML += prettifyEffects(card_effects);
			text.appendChild(effect);

			if (card_stats.pt != "") {
				const pt = document.createElement("div");
				pt.className = "pt";
				pt.textContent = card_stats.pt;
				text.appendChild(pt);
			}
			else if (card_stats.loyalty != "") {
				const loyalty = document.createElement("div");
				loyalty.className = "pt";
				loyalty.textContent = "[" + card_stats.loyalty + "]";
				text.appendChild(loyalty);
			}

			if (designer_notes && card_stats.designer_notes != null) {
				const dnotes = document.createElement("div");
				dnotes.className = "designer-notes";
				dnotes.innerHTML = "<u><b>Designer Notes</b></u>";
				dnotes.innerHTML = dnotes.innerHTML + card_stats.designer_notes;
				text.appendChild(dnotes);
			}

			// 13-name	14-color	15-type	16-ci	17-cost	18-ability	19-pt	20-special-text	21-loyalty
			if (card_stats.shape.includes("adventure") || card_stats.shape.includes("double") || card_stats.shape.includes("spli")) {
				const name_cost_2 = document.createElement("div");
				name_cost_2.className = "name-cost";
				name_cost_2.innerHTML = card_stats.card_name2 + (card_stats.cost2 != "" ? '     ' + symbolize(card_stats.cost2) : "");
				text.appendChild(name_cost_2);

				const type_2 = document.createElement("div");
				type_2.className = "type";
				type_2.textContent = card_stats.type2;
				text.appendChild(type_2);

				const effect_2 = document.createElement("div");
				effect_2.className = "effect";
				let card_effects_2 = "";
				if (card_stats.rules_text2 != "") {
					card_effects_2 = card_stats.rules_text2.split("\n");
				}
				else {
					card_effects_2 = card_stats.special_text2.split("\n");
				}
				effect_2.innerHTML += prettifyEffects(card_effects_2);
				text.appendChild(effect_2);

				if (card_stats.pt2 != "") {
					const pt_2 = document.createElement("div");
					pt_2.className = "pt";
					pt_2.textContent = card_stats.pt2;
					text.appendChild(pt_2);
				}
				else if (card_stats.loyalty2 != "") {
					const loyalty = document.createElement("div");
					loyalty.className = "pt";
					loyalty.textContent = "[" + card_stats.loyalty2 + "]";
					text.appendChild(loyalty);
				}
			}

			textContainer.appendChild(text);

			if (localStorage.getItem('info.lastdeck') != null) {
				const addToDeck = document.createElement('button');
				const lastdeck = localStorage.getItem('info.lastdeck');
				addToDeck.className = "add-to-deck";
				addToDeck.innerHTML = `<img src='img/plus.png' class='add-icon'>Add card to ${lastdeck}`;
				addToDeck.onclick = function () {
					let deck = localStorage.getItem(lastdeck);
					deck = deck + `1 ${card_stats.card_name}`;
					localStorage.setItem(lastdeck, deck);
					alert("Added to deck");
				}
				textContainer.appendChild(addToDeck);
			}

			grid.appendChild(textContainer);

			return grid;
		}

		function buildImgContainer(card_stats, hidden_title = false, rotate_card = false) {
			const imgContainer = document.createElement("div");
			imgContainer.className = "img-container";
			const id = card_stats.set + "-" + card_stats.number + "-" + document.getElementById("display").value;

			const img = document.createElement("img");
			img.className = "card-image";
			img.id = id;
			// (card_stats[13].includes("_") ? card_stats[13] : card_stats[0]) for posterity
			img.src = "/sets/" + card_stats.set + "-files/img/" + card_stats.number + (card_stats.shape.includes("token") ? "t_" : "_") + card_stats.card_name + ((card_stats.shape.includes("double")) ? "_front" : "") + "." + card_stats.image_type;

			let not_in_voyager;

			if (card_stats.set == "HEL") {
				img.style.filter = "grayscale()";

				not_in_voyager = document.createElement("span");
				not_in_voyager.className = "not-in-voyager";
				not_in_voyager.innerText = "This card is no longer legal in voyager.";
			}

			let banned_overlay;

			if (isBannedCard(card_stats.card_name)) {
				banned_overlay = document.createElement("div");
				banned_overlay.className = "banned-overlay";
			}

			const link = document.createElement("a");

			const url = new URL('card', window.location.origin);
			const params = {
				set: card_stats.set,
				num: card_stats.number,
				name: card_stats.card_name
			}
			for (const key in params) {
				url.searchParams.append(key, params[key]);
			}
			link.href = url;

			link.appendChild(img);

			if ((card_stats.shape.includes("spli") || card_stats.type.includes("Battle")) && rotate_card) {
				const rotated_img = document.createElement("img");
				rotated_img.className = "h-img";
				rotated_img.id = "h-img";
				rotated_img.src = img.src;
				rotated_img.style.display = "block";
				img.style.filter = "blur(2px) brightness(0.7)";

				link.appendChild(rotated_img);
			}

			if (banned_overlay) {
				link.appendChild(banned_overlay);
			}

			imgContainer.appendChild(link);

			if (card_stats.shape.includes("double")) {
				const imgFlipBtn = document.createElement("button");
				imgFlipBtn.className = "img-flip-btn btn";
				imgFlipBtn.onclick = async function () { imgFlip(id, rotate_card); };
				const imgFlipIcon = document.createElement("img");
				imgFlipIcon.className = "img-flip-icon";
				imgFlipIcon.src = '/img/flip.svg';
				imgFlipBtn.appendChild(imgFlipIcon);
				imgContainer.appendChild(imgFlipBtn);
			}

			if (hidden_title) {
				const title = document.createElement("div");
				title.innerText = card_stats.card_name;
				title.className = "hidden-text";
				imgContainer.appendChild(title);
			}

			if (not_in_voyager) {
				imgContainer.appendChild(not_in_voyager);
			}

			return imgContainer;
		}

		async function imgFlip(id, rotate_card = false) {
			const img = document.getElementById(id);
			const seconds = 0.15;
			const cardName = img.src;

			img.style.transition = seconds.toString() + "s";
			img.style.transform = "rotateY(90deg)";

			const btn = img.parentElement.parentElement.getElementsByTagName("button")[0];
			btn.style.transition = seconds.toString() + "s";
			btn.style.filter = cardName.includes("_front") ? "invert()" : "";

			await setTimeout(function () {
				const rotated_img = document.getElementById("h-img");

				if (cardName.includes("_front")) {
					img.src = cardName.replace("_front", "_back");
					img.parentElement.parentElement.getElementsByTagName("button")[0].style.filter = "invert()";

					if (rotate_card) {
						rotated_img.style.display = "none";
						img.style.filter = "";
					}
				}
				else {
					img.src = cardName.replace("_back", "_front");
					img.parentElement.parentElement.getElementsByTagName("button")[0].style.filter = "";

					if (rotate_card) {
						rotated_img.style.display = "block";
						img.style.filter = "blur(2px) brightness(0.7)";
					}
				}

				img.style.transition = (seconds * 2).toString() + "s";
				img.style.transform = "rotateY(0deg)";
			}, seconds * 1000);

			await setTimeout(function () {
				console.log("done");
			}, seconds * 1000);
		}


		function prettifyEffects(card_effects) {
			let HTML = "";

			for (let i = 0; i < card_effects.length; i++) {
				let styled_effect = card_effects[i].replaceAll("[i]", "<i>").replaceAll("[/i]", "</i>").replaceAll("[b]", "<b>").replaceAll("[/b]", "</b>");
				HTML += styled_effect;

				if (i != card_effects.length - 1) {
					HTML += "<br>"
				}
			}

			let regexHTML = symbolize(HTML);

			return regexHTML;
		}

		document.getElementById("search").addEventListener("keypress", function (event) {
			if (event.key === "Enter") {
				event.preventDefault();
				search();
			}
		});

		function search() {
			const url = new URL('search', window.location.origin);
			url.searchParams.append('search', document.getElementById("search").value);
			window.location.href = url;
		}

		function randomCard() {
			let i = Math.floor(Math.random() * (card_list_arrayified.length + 1));
			let random_card = card_list_arrayified[i];

			const url = new URL('card', window.location.origin);
			const params = {
				set: random_card.set,
				num: random_card.number,
				name: random_card.card_name
			}
			for (const key in params) {
				url.searchParams.append(key, params[key]);
			}

			window.location.href = url;
		}
	</script>
	<script type="module">
		// Import the functions you need from the SDKs you need
		import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js";
		import { setDoc, addDoc, updateDoc, doc, collection, getFirestore, query, where, getDocs, getDoc } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js";
		// TODO: Add SDKs for Firebase products that you want to use
		// https://firebase.google.com/docs/web/setup#available-libraries

		// Your web app's Firebase configuration
		// For Firebase JS SDK v7.20.0 and later, measurementId is optional
		const firebaseConfig = {
			apiKey: "AIzaSyCPurnKVn2caCn3L-gKF2tMFwWur73YAuw",
			authDomain: "voyager-78e30.firebaseapp.com",
			projectId: "voyager-78e30",
			storageBucket: "voyager-78e30.firebasestorage.app",
			messagingSenderId: "411191248476",
			appId: "1:411191248476:web:591349be169d823e5f8899",
			measurementId: "G-TQ1L48F25M"
		};

		// Initialize Firebase
		const app = initializeApp(firebaseConfig);
		const db = getFirestore(app);
		let username = "";
		let password = "";
		let sessionid = localStorage.getItem('settings.session');
		let decks = {};
		const events = ["GP1", "League"];
		let user_data;
		const urlParams = new URLSearchParams(window.location.search);

		if (sessionid) {
			await getDoc(doc(db, 'sessions', sessionid)).then(docSnap => {
				let data = docSnap.data();
				username = data.username;
				password = data.password;
			});

			await getDoc(doc(db, 'users', username)).then(docSnap => {
				let data = docSnap.data();
				user_data = data;
			});
		}



		async function reload() {
			const image_grid = document.getElementsByClassName("image-grid")[0];

			const rulings_container = document.getElementsByClassName("rulings-container")[0];

			if (user_data?.judge) {
				const rulings_input_container = document.createElement("div");
				rulings_input_container.className = "rulings-input-container";

				const rulings_input = document.createElement("textarea");
				rulings_input.style.resize = "none";
				rulings_input.placeholder = "Add card rulings...";
				rulings_input.className = "rulings-textarea";

				const submit_rulings = document.createElement("button");
				submit_rulings.className = "rulings-submit-btn popout";
				submit_rulings.innerText = "Upload this ruling";
				submit_rulings.onclick = submitRulings;

				rulings_input_container.appendChild(rulings_input);
				rulings_input_container.appendChild(submit_rulings);
				rulings_container.appendChild(rulings_input_container);
			}

			const rulings = await fetchRulings(urlParams.get("name"));

			const current_rulings = document.createElement("div");
			current_rulings.className = "rulings-list text";
			current_rulings.innerHTML = "Rulings:<br>" + rulings.list;
			rulings_container.appendChild(current_rulings);

			if (rulings.has_rulings || user_data?.judge) {
				image_grid.appendChild(rulings_container);
				image_grid.className += " image-grid-with-rulings";
			}

			getCardStats();
		}

		async function submitRulings() {
			const ruling_to_submit = document.getElementsByClassName("rulings-textarea")[0].value;
			await getDoc(doc(db, "info", "rulings")).then(async docSnap => {
				let cardl = docSnap.data()[urlParams.get("name")] ? docSnap.data()[urlParams.get("name")] : [];
				let card_obj = {};
				card_obj[urlParams.get("name")] = [...cardl, ruling_to_submit];
				await updateDoc(doc(db, "info", "rulings"), card_obj);
				window.location.reload();
			});
		}

		async function fetchRulings(card_name) {
			let rulings_json;
			let firebase_list;
			await fetch('/data/rulings/rulings.json')
				.then(response => response.json())
				.then(data => {
					rulings_json = data;
				}).catch(error => console.error('Error:', error));

			let card_rulings = rulings_json[card_name] ? rulings_json[card_name] : [];

			await getDoc(doc(db, "info", "rulings")).then(docSnap => {
				firebase_list = docSnap.data()[card_name] ? docSnap.data()[card_name] : [];
			});

			const rulings_list = [...firebase_list, ...card_rulings];

			return { list: convertToLi(rulings_list), has_rulings: (rulings_list.length > 0) };
		}

		function convertToLi(list) {
			let ret = "";
			ret += "<ol>";
			for (const item of list) {
				ret += `<li>${item}</li>`;
			}
			ret += "</ol>";
			return ret
		}

		async function getCardStats() {
			const card_name = decodeURI(urlParams.get("name"));
			let num_event_decks = 0;
			let num_user_decks = 0;
			let num_decks = 0;

			let q = query(collection(db, "events"));
			let all_events_docs = await getDocs(q);

			q = query(collection(db, "users"));
			let all_users_docs = await getDocs(q);

			let all_event_decks = [];
			let all_user_decks = [];
			let all_decks = [];
			let all_events = [];
			let decks_with_card = [];

			all_events_docs.forEach((doc) => {
				const data = doc.data();
				all_events.push(data);
				for (const user in data.decks) {
					let deck = data.decks[user];
					all_event_decks.push({ ...deck, "user": user, "event": true });
					all_decks.push({ ...deck, "user": user, "event": true });
				}
			});

			all_users_docs.forEach((doc) => {
				const data = doc.data();
				for (const deck of data.decks) {
					all_user_decks.push({ ...deck, "user": data.username, "event": false });
					all_decks.push({ ...deck, "user": data.username, "event": false });
				}
			});

			for (const deck of all_event_decks) {
				const decklist = atob(deck.url.split(';')[1].split('&main')[0]);
				for (const line of decklist.split("\n")) {
					if (line.substring(line.indexOf(" ") + 1, line.length) == card_name) {
						num_event_decks += 1;
						decks_with_card.push(deck);
					}
				}
			}

			for (const deck of all_user_decks) {
				const decklist = atob(deck.url.split(';')[1].split('&main')[0]);
				for (const line of decklist.split("\n")) {
					if (line.substring(line.indexOf(" ") + 1, line.length) == card_name) {
						num_user_decks += 1;
						decks_with_card.push(deck);
					}
				}
			}

			num_decks = num_user_decks + num_event_decks;

			let total_games = 0;
			let total_wins = 0;

			for (const event of all_events) {
				if (event.name.includes("League")) continue;
				const swiss = JSON.parse(event.rounds).swiss;
				const decks = event.decks;
				let players_with_card = [];
				for (const player in decks) {
					const deck = decks[player];
					const decklist = atob(deck.url.split(';')[1].split('&main')[0]);
					for (const line of decklist.split("\n")) {
						if (line.substring(line.indexOf(" ") + 1, line.length) == card_name) {
							players_with_card.push(player);
							break;
						}
					}
				}
				for (const round_name in swiss) {
					const round = swiss[round_name];
					for (const game of round) {
						const p1 = Object.keys(game)[0];
						const p2 = Object.keys(game)[1];

						const p1_score = parseInt(game[p1]);
						const p2_score = parseInt(game[p2]);

						let winner = 0;
						if (p1_score > p2_score)
							winner = p1;
						if (p1_score < p2_score)
							winner = p2;

						if (players_with_card.includes(p1)) {
							if (winner == p1) {
								total_wins++;
							}
							if (winner != 0)
								total_games++;
						}
						if (players_with_card.includes(p2)) {
							if (winner == p2) {
								total_wins++;
							}
							if (winner != 0)
								total_games++;
						}
					}
				}
			}

			const winrate = ((total_wins / total_games) * 100).toFixed(2).toString() + "%";
			const playrate_event_text = ((num_event_decks / all_event_decks.length) * 100).toFixed(2).toString() + "%";
			const playrate_user_text = ((num_user_decks / all_user_decks.length) * 100).toFixed(2).toString() + "%";
			const playrate_text = ((num_decks / all_decks.length) * 100).toFixed(2).toString() + "%";

			const stats = {
				winrate: ["GP Winrate", winrate],
				playrate_event: ["Event Playrate", playrate_event_text],
				playrate_user: ["User Playrate", playrate_user_text],
				playrate_general: ["Overall Playrate", playrate_text],
				decks: [false, decks_with_card]
			}

			const viewStats = document.createElement('button');
			const lastdeck = localStorage.getItem('info.lastdeck');
			viewStats.className = "view-stats";
			viewStats.innerHTML = `<img src='img/show-white.png' class='add-icon'>View Stats`;
			viewStats.onclick = () => { openStatsModal(stats) };
			document.getElementsByClassName("text-container")[0].appendChild(viewStats);
		}

		function openStatsModal(stats) {
			const card_name = decodeURI(urlParams.get("name"));

			const content_container = document.createElement("div");
			content_container.className = "full-stats-container";

			const table_container = document.createElement("div");
			table_container.className = "stats-container";

			const decks_container = document.createElement("div");
			decks_container.className = "decks-stats-container";

			const stats_header = document.createElement("h2");
			stats_header.className = "decks-header";
			stats_header.innerText = `Stats`;

			for (const stat in stats) {
				if (!stats[stat][0]) continue;
				const stat_name = stats[stat][0];
				const stat_value = stats[stat][1];

				const stat_title = document.createElement("span");
				stat_title.className = "stat-title";
				stat_title.innerText = stat_name;

				const stat_ele = document.createElement("span");
				stat_ele.className = "stat-value";
				stat_ele.innerText = stat_value;

				table_container.appendChild(stat_title);
				table_container.appendChild(stat_ele);
			}

			const is_played = document.createElement("span");
			is_played.className = "is-played ";
			is_played.innerText = "Played";
			is_played.className += isPlayed(stats) ? "played" : "not-played";

			const is_staple = document.createElement("span");
			is_staple.className = "is-played ";
			is_staple.innerText = "Staple";
			is_staple.className += isStaple(stats) ? "played" : "not-played";

			const page_link = document.createElement("a");
			page_link.className = "stats-link stat-value";
			page_link.innerText = "View detailed stats";
			page_link.href = window.location.href.replace("card", "stats");

			const decks_header = document.createElement("h2");
			decks_header.className = "decks-header";
			decks_header.innerText = `Decks with ${card_name}`;

			let decks = stats.decks[1];

			decks.sort(newDeck);

			for (let i = 0; i < Math.min(6, decks.length); i++) {
				const deck = decks[i];

				const deck_container = gridifyDeck(deck);

				decks_container.appendChild(deck_container);
			}

			if (decks.length == 0) {
				const text = document.createElement("span");
				text.innerText = "⚠️ No decks found containing " + card_name;
				decks_container.appendChild(text);
				decks_container.style.display = "block";
			}

			table_container.appendChild(is_played);
			table_container.appendChild(is_staple);
			table_container.appendChild(page_link);

			content_container.appendChild(stats_header);
			content_container.appendChild(table_container);
			content_container.appendChild(decks_header);
			content_container.appendChild(decks_container);

			document.getElementById("modal-content").innerHTML = "";
			document.getElementById("modal-content").appendChild(content_container);
			document.getElementById("modal-container").style.display = "block";
		}

		function gridifyDeck(deck) {
			const container = document.createElement("div");
			container.className = "deck-container";
			const preview_img = document.createElement("img");
			let card_stats;
			for (const card of card_list_arrayified) {
				if (deck.previewimg == card.card_name) {
					card_stats = card;
					break;
				}
			}
			preview_img.src = card_stats ? "/sets/" + card_stats.set + "-files/img/" + card_stats.number + (card_stats.shape.includes("token") ? "t_" : "_") + card_stats.card_name + ((card_stats.shape.includes("double")) ? "_front" : "") + "." + card_stats.image_type : "img/card_back.png";
			preview_img.className = "deck-preview-img";
			preview_img.onclick = function () {
				if (deck.event) {
					window.location.href = `/deckbuilder?edeck=${deck.event}-${deck.user}`;
					return;
				}
				window.location.href = `/deck?deck=${deck.user}-${encodeURI(deck.name)}`;
			}
			const deck_name = document.createElement("div");
			deck_name.className = "deck-name";
			deck_name.innerText = deck.name;

			container.appendChild(deck_name);
			container.appendChild(preview_img);
			return container;
		}

		function newDeck(a, b) {
			if (a.last_modified && !b.last_modified) {
				return -1;
			}
			if (!a.last_modified && b.last_modified) {
				return 1;
			}
			if (!a.last_modified && !b.last_modified) {
				return 0;
			}

			let a_date = {};
			let b_date = {};

			let a_split = a.last_modified.split(',');
			let a_split2 = a_split[0].split('-');

			a_date.day = Number(a_split2[0]);
			a_date.month = Number(a_split2[1]);
			a_date.year = Number(a_split2[2]);

			a_date.hour = Number(a_split[1].split(":")[0]);
			a_date.min = Number(a_split[1].split(":")[1]);

			let b_split = b.last_modified.split(',');
			let b_split2 = b_split[0].split('-');

			b_date.day = Number(b_split2[0]);
			b_date.month = Number(b_split2[1]);
			b_date.year = Number(b_split2[2]);

			b_date.hour = Number(b_split[1].split(":")[0]);
			b_date.min = Number(b_split[1].split(":")[1]);

			if (a_date.year > b_date.year) {
				return -1;
			}
			if (a_date.year < b_date.year) {
				return 1;
			}
			if (a_date.month > b_date.month) {
				return -1;
			}
			if (a_date.month < b_date.month) {
				return 1;
			}
			if (a_date.day > b_date.day) {
				return -1;
			}
			if (a_date.day < b_date.day) {
				return 1;
			}
			if (a_date.hour > b_date.hour) {
				return -1;
			}
			if (a_date.hour < b_date.hour) {
				return 1;
			}
			if (a_date.min > b_date.min) {
				return -1;
			}
			if (a_date.min < b_date.min) {
				return 1;
			}
			return 0;
		}

		function isPlayed(stats) {
			const playrate = parseFloat(stats.playrate_general[1].split("%")[0]);
			if (playrate > 2) {
				return true;
			}
		}

		function isStaple(stats) {
			const playrate = parseFloat(stats.playrate_general[1].split("%")[0]);
			const playrate_event = parseFloat(stats.playrate_event[1].split("%")[0]);
			const winrate = parseFloat(stats.winrate[1].split("%")[0]);
			if (playrate > 8 && winrate > 30 && playrate_event > 0.01) {
				return true;
			}
		}

		const delay = ms => new Promise(res => setTimeout(res, ms));

		document.addEventListener("DOMContentLoaded", async () => {
			while (document.getElementsByClassName("rulings-container").length == 0) {
				await delay(100);
			}
			reload();
		});
	</script>
</body>

</html>