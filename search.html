<html>

<head>
	<title>Search</title>
	<link rel="icon" type="image/x-icon" href="/img/header/search.png">
	<link rel="stylesheet" href="resources/mana.css">
	<link rel="stylesheet" href="/resources/header.css">
</head>
<style>
	@font-face {
		font-family: Beleren;
		src: url('/resources/beleren.ttf');
	}

	body {
		font-family: 'Helvetica', 'Arial', sans-serif;
		overscroll-behavior: none;
		margin: 0px;
		background-color: #f3f3f3;
		background-attachment: fixed;
		background-size: cover;
	}

	.button-grid {
		width: 70%;
		max-width: 1200px;
		height: 40px;
		margin: auto;
		display: grid;
		grid-template-columns: 4fr 1fr;
		gap: 10px;
		padding-top: 20px;
		padding-bottom: 20px;
		justify-items: center;
	}

	.prev-next-btns {
		width: 100%;
		height: 40px;
		margin: auto;
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 5px;
		align-items: center;
	}

	button:not(.btn) {
		background-color: #fafafa;
		border: 1px solid #d5d9d9;
		border-radius: 8px;
		box-shadow: rgba(213, 217, 217, .5) 0 2px 5px 0;
		color: #171717;
		cursor: pointer;
		font-size: 13px;
		width: 100%;
		height: 35px;
		min-width: 85px;
	}

	button:hover {
		background-color: #ffffff;
	}

	button:focus {
		border-color: #171717;
		box-shadow: rgba(213, 217, 217, .5) 0 2px 5px 0;
		outline: 0;
	}

	button:disabled {
		cursor: auto;
		background-color: #f7fafa;
		font-style: italic;
		box-shadow: none;
		color: #cccccc;
	}

	.button-grid .results-text {
		margin-right: -3px;
	}

	.button-grid .select-text {
		width: 100%;
		display: flex;
		align-items: center;
		justify-content: left;
		gap: 8px;
		font-size: 14.5px;
		text-align: center;
	}

	select {
		background-color: #fafafa;
		border: 1px solid #d5d9d9;
		border-radius: 8px;
		box-shadow: rgba(213, 217, 217, .5) 0 2px 5px 0;
		text-align: center;
		color: #171717;
		font-size: 13px;
		height: 30px;
	}

	.grid-container {
		display: grid;
		grid-template-columns: auto;
		max-width: 1200px;
		margin: auto;
	}

	.image-grid-container {
		display: grid;
		grid-template-columns: 1fr 1fr 1fr 1fr;
		width: 70%;
		max-width: 1200px;
		margin: auto;
		gap: 5px;
		justify-items: center;
	}

	@media (max-width: 750px) {
		.image-grid-container {
			grid-template-columns: 1fr 1fr;
		}
	}

	.image-grid {
		width: 70%;
		margin: auto;
		display: grid;
		grid-template-columns: minmax(150px, 1fr) minmax(300px, 2fr);
		gap: 50px;
		padding-bottom: 10px;
		justify-items: left;
	}

	.image-grid img {
		position: relative;
	}

	.card-image {
		float: left;
		width: 100%;
		height: auto;
		display: block;
		border-radius: 9px;
		transition: 0.2s;
	}

	.card-image:hover {
		filter: brightness(0.7);
	}

	.card-text {
		padding-top: 20px;
		padding-bottom: 20px;
		background: #fcfcfc;
		width: 100%;
		border: 1px solid #d5d9d9;
		border-top: 3px solid #171717;
		border-bottom: 3px solid #171717;
		border-radius: 6px;
		height: fit-content;
		min-height: 75%;
		margin-top: 3%;
	}

	.card-text div {
		white-space: normal;
		font-size: 15px;
		padding-bottom: 10px;
		padding-left: 12px;
		padding-right: 12px;
		line-height: 155%;
	}

	.card-text .name-cost {
		font-size: 20px;
		white-space: pre-wrap;
	}

	.card-text .type {
		font-size: 16px;
	}

	.card-text .pt {
		font-weight: bold;
	}

	.card-text br {
		content: "";
		display: block;
		margin-bottom: 5px;
	}

	.img-container {
		position: relative;
		width: 100%;
		align-self: center;
	}

	.img-container img {
		width: 100%;
		height: auto;
	}

	.img-container .btn {
		background-color: #ffffffaa;
		background-size: contain;
		background-position: center;
		width: 15%;
		height: 11%;
		cursor: pointer;
		border: none;
		position: absolute;
		left: 50%;
		top: 48%;
		transform: translate(170%, -150%);
		opacity: 0.8;
		border-radius: 100%;
		border: 2px solid black;
		padding: 3px;
	}

	.img-container .btn:hover {
		background-size: contain;
		background-position: center;
		background-color: #ffffff;
	}

	.img-container .hidden-text {
		position: absolute;
		font-family: Beleren;
		top: 5%;
		left: 9%;
		font-size: .97vw;
		color: rgba(0, 0, 0, 0);
	}

	#modal-container {
		display: none;
		position: fixed;
		z-index: 1;
		padding-top: 70px;
		left: 0;
		top: 0;
		width: 100%;
		height: 100%;
		overflow: auto;
		background-color: rgb(0, 0, 0);
		background-color: rgba(0, 0, 0, 0.4);
	}

	#modal-content {
		background-color: #fefefe;
		margin: auto;
		padding: 20px;
		border: 1px solid #888;
		width: 50%;
		border-radius: 10px;
		border: solid #777 3px;
		margin-bottom: 70px;
	}
</style>
<style id="text-style">
	.text {
		color: white;
	}
</style>
<style id="popout-style">
	.popout {
		background-color: #f3f3f3;
		/* color: #f3f3f3; */
	}
</style>

<body>
	<div class="header">
		<div class="search-grid">
			<a href="/"><img class="sg-logo" src="/img/banner.png"></a>
			<img class="sg-icon" src="/img/header/search.png">
			<div><input type="text" inputmode="search" placeholder="Search ..." name="search" id="search"
					spellcheck="false" autocomplete="off" autocorrect="off" spellcheck="false"><img src="img/info.png"
					class="search-info" onclick="goToOnboard()"></div>
			<a href="/all-sets"><img src="/img/header/sets.png" class="sg-icon">Sets</a>
			<a href="/deckbuilder"><img src="/img/header/deck.png" class="sg-icon">Deckbuilder</a>
			<a onclick="randomCard()"><img src="/img/random.png" class="sg-icon">Random</a>
			<a href="/community" id="account-link"><img src="/img/header/community.png" class="sg-icon">Community</a>
			<a href="/settings" id="account-link"><img src="/img/header/settings.png" class="sg-icon"></a>
			<a href="/account" id="account-link"><img src="/img/header/account.png" class="sg-icon"></a>
		</div>
	</div>
	<div class="button-grid">
		<div class="select-text text">
			<div class="results-text" id="results-text">Loading ...</div>Cards displayed as<select name="display"
				id="display" class="popout">
				<option value="cards-only">Cards Only</option>
				<option value="cards-text">Cards + Text</option>
			</select>sorted by<select name="sort-by" id="sort-by" class="popout">
				<option value="name">Name</option>
				<option value="set-code">Set / Number</option>
				<option value="mv">Mana Value</option>
				<option value="color">Color</option>
				<option value="rarity">Rarity</option>
			</select> : <select name="sort-order" id="sort-order" class="popout">
				<option value="ascending">Asc</option>
				<option value="descending">Desc</option>
			</select>
		</div>
		<div class="prev-next-btns">
			<button class="popout" type="submit" onclick="previousPage()" id="prevBtn" disabled>
				< Previous</button>
					<button class="popout" type="submit" onclick="nextPage()" id="nextBtn">Next 30 ></button>
		</div>
	</div>

	<div class="grid-container" id="grid">
	</div>

	<div class="image-grid-container" id="imagesOnlyGrid">
	</div>

	<div class="button-grid" id="footer">
		<div></div>
		<div class="prev-next-btns">
			<button class="popout" type="submit" onclick="previousPage()" id="prevBtn-footer" disabled>
				< Previous</button>
					<button class="popout" type="submit" onclick="nextPage()" id="nextBtn-footer">Next 30 ></button>
		</div>
	</div>

	<button id="get-stats" style="display: none;"></button>

	<div id="modal-container">
		<div id="modal-content" class="popout">
			<span class="close" onclick="closeModal()">&times;</span>
		</div>
	</div>

	<script>
		let page = 0;
		let pageCount = 30;
		let search_results = [];
		let card_list_arrayified = [];
		let specialchars = "";
		let sets_json = {};
		let all_cards_stats;
		const delay = ms => new Promise(res => setTimeout(res, ms));

		document.addEventListener("DOMContentLoaded", async function () {
			await fetch('/lists/all-cards.json')
				.then(response => response.json())
				.then(json => {
					card_list = json;
				}).catch(error => console.error('Error:', error));

			await fetch('/lists/all-sets.json')
				.then(response => response.json())
				.then(json => {
					set_list = json;
				}).catch(error => console.error('Error:', error));

			await fetch('/resources/replacechars.txt')
				.then(response => response.text())
				.then(text => {
					specialchars = text;
				}).catch(error => console.error('Error:', error));

			card_list_arrayified = card_list.cards;


			await fetch('/lists/all-sets.json')
				.then(response => response.json())
				.then(data => {
					sets_json = data;
				}).catch(error => console.error('Error:', error));

			if (sessionStorage.getItem("display") != "cards-only") {
				cardGrid = document.getElementById("grid");
			}
			else {
				cardGrid = document.getElementById("imagesOnlyGrid");
			}

			card_list_arrayified.sort(compareFunction);

			// refresh page values
			const params = new URLSearchParams(window.location.search);
			page = params.get("page") ? params.get("page") : 0;
			document.getElementById("search").value = params.get("search") ? decodeURIComponent(params.get("search")) : "";

			if (sessionStorage.getItem("sortMethod")) {
				document.getElementById("sort-by").value = sessionStorage.getItem("sortMethod");
			}
			if (sessionStorage.getItem("display")) {
				document.getElementById("display").value = sessionStorage.getItem("display");
			}

			displayStyle = document.getElementById("display").value;
			setCardView();

			defaultSetting('settings.autosave', 'On');
			defaultSetting('settings.searchalias', 'On');
			defaultSetting('settings.exportcube', 'On');
			defaultSetting('settings.gradient', 'Random-Card');

			try {
				const response = await fetch('/resources/gradients.json');
				raw_gradients = await response.json();
			}
			catch (error) {
				console.error('Error:', error);
			}

			gradients = raw_gradients.gradients;
			card_backgrounds = raw_gradients.cards;
			setGradient(localStorage.getItem("settings.gradient"));

			document.getElementById('text-style').innerHTML = `.text { color: ${localStorage.getItem('settings.textcolor')} }`;
			document.getElementById('text-style').innerHTML += `\n.text-bg { background-color: ${localStorage.getItem('settings.textcolor')} }`;

			if (localStorage.getItem("settings.darkthememenu") == "On") {
				document.getElementById("popout-style").innerHTML = ".popout { background-color: #000 !important; color: #f3f3f3 !important; }";
			} else if (localStorage.getItem("settings.darkthememenu") == "Off") {
				document.getElementById("popout-style").innerHTML = ".popout { background-color: #f3f3f3 !important;  }";
			}

			// initial search on load
			preSearch(false);
		});

		function defaultSetting(name, default_) {
			if (localStorage.getItem(name) == null) {
				localStorage.setItem(name, default_);
			}
		}

		function displayChangeListener() {
			displayStyle = document.getElementById("display").value;
			sessionStorage.setItem("display", displayStyle);
			sessionStorage.setItem("sortMethod", document.getElementById("sort-by").value);

			setCardView();

			preSearch(false);
		}

		document.getElementById("sort-by").onchange = displayChangeListener;
		document.getElementById("display").onchange = displayChangeListener;
		document.getElementById("sort-order").onchange = displayChangeListener;

		window.addEventListener('popstate', function (event) {
			let params = decodeURIComponent(window.location.href.indexOf("?search") == -1 ? "" : window.location.href.substring(window.location.href.indexOf("?search") + 8), (window.location.href.indexOf("page=") == -1 ? window.location.href.length : window.location.href.indexOf("page=")));
			document.getElementById("search").value = (params.indexOf("&page=") == -1 ? params.replaceAll("+", " ") : params.substring(0, params.indexOf("&page=")).replaceAll("+", " "));
			page = window.location.href.indexOf("page=") == -1 ? 0 : parseInt(window.location.href.substring(window.location.href.indexOf("page=") + 5)) - 1;

			preSearch(false);
		});

		function setCardView() {
			imagesOnlyGrid.style.display = displayStyle == "cards-only" ? '' : 'none';
			grid.style.display = displayStyle == "cards-only" ? 'none' : '';
		}

		function compareFunction(a, b) {
			const sortMode = document.getElementById("sort-by").value;

			if (a.rarity.includes("masterpiece") && !b.rarity.includes("masterpiece")) {
				return 1;
			}

			if (!a.rarity.includes("masterpiece") && b.rarity.includes("masterpiece")) {
				return -1;
			}

			if (a.shape.includes("token") && !b.shape.includes("token")) {
				return 1;
			}

			if (!a.shape.includes("token") && b.shape.includes("token")) {
				return -1;
			}

			if (sortMode == 'set-code') {
				if (a.set === b.set) {
					if (a.number === b.number) {
						return 0;
					}
					else {
						return (a.number < b.number) ? -1 : 1;
					}
				}
				else {
					return (a.set < b.set) ? -1 : 1;
				}
			}
			if (sortMode == 'name') {
				if (a.card_name === b.card_name) {
					return 0;
				}
				else {
					return (a.card_name < b.card_name) ? -1 : 1;
				}
			}
			if (sortMode == 'mv') {
				//since cost is now formatted like {1}{U} instead of 1U, we need to remove the brackets from the string first
				//CE: undoing this because we're counting { chars for MV
				a_mv = isDecimal(a.cost.charAt(1)) ? parseInt(a.cost.substring(1, a.cost.indexOf('}'))) + a.cost.replaceAll('x', '').split('{').length - 2 : a.cost.replaceAll('x', '').split('{').length - 1;
				b_mv = isDecimal(b.cost.charAt(1)) ? parseInt(b.cost.substring(1, b.cost.indexOf('}'))) + b.cost.replaceAll('x', '').split('{').length - 2 : b.cost.replaceAll('x', '').split('{').length - 1;
				if (a_mv === b_mv) {
					if (a.card_name === b.card_name) {
						return 0;
					}
					else {
						return (a.card_name < b.card_name) ? -1 : 1;
					}
				}
				else {
					return (a_mv < b_mv) ? -1 : 1;
				}
			}
			if (sortMode == 'color') {
				color_sort_order = ["W", "U", "B", "R", "G", "WU", "UB", "BR", "RG", "GW", "WB", "UR", "BG", "RW", "GU", "WUB", "UBR", "BRG", "RGW", "GWU", "RWB", "GUR", "WBG", "URW", "BGU", "WUBR", "UBRG", "BRGW", "RGWU", "GWUB", "WUBRG", ""];
				a_color_index = -1;
				b_color_index = -1;

				for (let i = 0; i < color_sort_order.length; i++) {
					if (a.color.toLowerCase().split('').sort().join('') == color_sort_order[i].toLowerCase().split('').sort().join('')) {
						a_color_index = i;
					}
					if (b.color.toLowerCase().split('').sort().join('') == color_sort_order[i].toLowerCase().split('').sort().join('')) {
						b_color_index = i;
					}
				}

				if (a_color_index === b_color_index) {
					if (a.card_name === b.card_name) {
						return 0;
					}
					else {
						return (a.card_name < b.card_name) ? -1 : 1;
					}
				}
				else {
					return (a_color_index < b_color_index) ? -1 : 1;
				}
			}
			if (sortMode == 'rarity') {
				rarity_sort_order = ["mythic", "rare", "uncommon", "common"];
				a_rarity_index = 100;
				b_rarity_index = 100;

				for (let i = 0; i < rarity_sort_order.length; i++) {
					if (a.rarity.toLowerCase() == rarity_sort_order[i]) {
						a_rarity_index = i;
					}
					if (b.rarity.toLowerCase() == rarity_sort_order[i]) {
						b_rarity_index = i;
					}
				}

				if (a_rarity_index === b_rarity_index) {
					color_sort_order = ["W", "U", "B", "R", "G", "WU", "UB", "BR", "RG", "GW", "WB", "UR", "BG", "RW", "GU", "WUB", "UBR", "BRG", "RGW", "GWU", "RWB", "GUR", "WBG", "URW", "BGU", "WUBR", "UBRG", "BRGW", "RGWU", "GWUB", "WUBRG", ""];
					a_color_index = -1;
					b_color_index = -1;

					for (let i = 0; i < color_sort_order.length; i++) {
						if (a.color.toLowerCase().split('').sort().join('') == color_sort_order[i].toLowerCase().split('').sort().join('')) {
							a_color_index = i;
						}
						if (b.color.toLowerCase().split('').sort().join('') == color_sort_order[i].toLowerCase().split('').sort().join('')) {
							b_color_index = i;
						}
					}

					if (a_color_index === b_color_index) {
						if (a.card_name === b.card_name) {
							return 0;
						}
						else {
							return (a.card_name < b.card_name) ? -1 : 1;
						}
					}
					else {
						return (a_color_index < b_color_index) ? -1 : 1;
					}
				}
				else {
					return (a_rarity_index < b_rarity_index) ? -1 : 1;
				}
			}
		}

		function preSearch(setNewState) {
			card_list_arrayified.sort(compareFunction);
			if (document.getElementById("sort-order").value == "descending") {
				card_list_arrayified.reverse();
			}
			search_results = [];
			page = setNewState ? 0 : page;

			search(setNewState);
		}

		async function search(setNewState) {
			searchTerms = document.getElementById("search").value.toLowerCase();

			if (searchTerms != "") {
				if (setNewState) {
					let url = (window.location.href.indexOf("?") == -1 ? new URL(window.location.href) : new URL(window.location.href.substring(0, window.location.href.indexOf("?"))));
					let params = new URLSearchParams(url.search);
					params.append("search", searchTerms);
					history.pushState({}, '', url.pathname + '?' + params.toString());
				}
			}
			else {
				if (setNewState) {
					let url = (window.location.href.indexOf("?") == -1 ? new URL(window.location.href) : new URL(window.location.href.substring(0, window.location.href.indexOf("?"))));
					let params = new URLSearchParams(url.search);
					params.delete("search");
					history.pushState({}, '', url.pathname + '' + params.toString());
				}
			}

			if (displayStyle == "cards-only") {
				cardGrid = document.getElementById("imagesOnlyGrid");
			}
			else {
				cardGrid = document.getElementById("grid");
			}
			cardGrid.innerHTML = "";

			for (const card of card_list_arrayified) {
				if (card.shape.includes("token") && !searchTerms.includes("+t:token") && !searchTerms.includes("t:token")) {
					continue;
				}

				if (card.type.includes("Basic") && !searchTerms.includes("+t:basic") && !searchTerms.includes("t:basic")) {
					continue;
				}

				if (card.rarity.includes("masterpiece") && !searchTerms.includes("+r:masterpiece") && !searchTerms.includes("+r:mp") && !searchTerms.includes("t:basic")) {
					continue;
				}

				searched = await searchAllTokens(card, tokenizeTerms(searchTerms));

				if (searched && !containsCard(search_results, card)) {
					search_results.push(card);
				}
			}

			if (search_results.length == 1) {
				const card = search_results[0];
				window.location.href = `https://voyager-mtg.github.io/card?set=${card.set}&num=${card.number}&name=${card.card_name.replaceAll(" ", "+")}`; //https://voyager-mtg.github.io/card?set=PVR&num=304&name=Pool+of+Becoming
			}

			if (searchTerms != "") {
				document.getElementById("results-text").innerText = search_results.length + (search_results.length == 1 ? " result found." : " results found.");
			}
			else {
				document.getElementById("results-text").innerText = "";
			}

			if (page != 0) {
				document.getElementById("prevBtn").disabled = false;
				document.getElementById("prevBtn-footer").disabled = false;
			}
			else {
				document.getElementById("prevBtn").disabled = true;
				document.getElementById("prevBtn-footer").disabled = true;
			}

			// set text of Next to match number of displayed images
			displayStyle = document.getElementById("display").value;
			pageCount = displayStyle == "cards-only" ? 60 : 30;
			document.getElementById("nextBtn").innerText = "Next " + pageCount + " >";
			document.getElementById("nextBtn-footer").innerText = "Next " + pageCount + " >";

			// really awesome code block to fix the URL when switching from Cards + Text view to Cards Only view
			while ((pageCount * page) > search_results.length) {
				page = page - 1;

				let url = (window.location.href.indexOf("page=") == -1 ? new URL(window.location.href) : new URL(window.location.href.substring(0, window.location.href.indexOf("page="))));
				let params = new URLSearchParams(url.search);
				params.append("page", page + 1);
				history.replaceState({}, '', url.pathname + '?' + params.toString());
			}

			for (let i = (pageCount * page); i < Math.min((pageCount * (page + 1)), search_results.length); i++) {
				cardGrid.appendChild(gridifyCard(search_results[i]));
			}

			if (search_results.length <= (pageCount * (page + 1))) {
				document.getElementById("nextBtn").disabled = true;
				document.getElementById("nextBtn-footer").disabled = true;
			}
			else {
				document.getElementById("nextBtn").disabled = false;
				document.getElementById("nextBtn-footer").disabled = false;
			}

			if (search_results.length < 10) {
				document.getElementById("nextBtn-footer").style.display = "none";
				document.getElementById("prevBtn-footer").style.display = "none";
			}
			if (search_results.length > 10) {
				document.getElementById("nextBtn-footer").style.display = "";
				document.getElementById("prevBtn-footer").style.display = "";
			}
		}

		function containsCard(list, card) {
			for (const li of list) {
				if (li.card_name == card.card_name && li.type == card.type) {
					return true;
				}
			}

			return false;
		}

		function tokenizeTerms(searchTerms) {
			let tokenRegex = /-?\w*[!:<>=]?(([^ "\(\)“”]+)|(\".+?\")|(\(.+?\))|(\/.+?\/)|(\“.+?\”))/g;
			let searchTokens = searchTerms.match(tokenRegex);

			return searchTokens;
		}

		async function searchAllTokens(card, tokens) {
			if (tokens == null || tokens == '') {
				return true;
			}
			for (let i = 0; i < tokens.length; i++) {
				if (tokens[i].charAt(0) == '+') {
					return await searchAllTokens(card, tokens.slice(0, i)) && await searchAllTokens(card, tokens.slice(i + 1));
				}
				if (tokens[i] == "or") {
					return await searchAllTokens(card, tokens.slice(0, i)) || await searchAllTokens(card, tokens.slice(i + 1));
				}
			}

			for (let token of tokens) {
				if (token.charAt(0) == '-') {
					return !(await searchToken(card, token.substring(1))) && (tokens.length == 1 ? true : await searchAllTokens(card, tokens.slice(1)));
				}
				if (token.charAt(0) == '(') {
					return await searchAllTokens(card, tokenizeTerms(token.substring(1, token.length - 1))) && (tokens.length == 1 ? true : await searchAllTokens(card, tokens.slice(1)));
				}
				else {
					return await searchToken(card, token) && (tokens.length == 1 ? true : await searchAllTokens(card, tokens.slice(1)));
				}
			}
		}

		function removeDuplicateChars(str) {
			let ret_str = '';

			for (const c of str) {
				if (!ret_str.includes(c)) {
					ret_str += c;
				}
			}

			return ret_str;
		}

		function convertToMV(cost) {
			let mv = 0;

			costTokens = cost.substring(1, cost.length - 1).replaceAll("}{", " ").split(' ');
			for (const token of costTokens) {
				if (isDecimal(token)) {
					mv += parseInt(token);
				}
				// 2brid
				else if (token.includes('2')) {
					mv += 2;
				}
				else if (token != "x") {
					mv += 1;
				}
			}

			return mv;
		}

		async function searchToken(card, token) {
			let card_stats = [];

			for (var key in card) {
				if (isNaN(card[key])) {
					card_stats[key] = card[key].toLowerCase();
				}
				else {
					card_stats[key] = card[key];
				}
			}

			let card_name = card_stats.card_name;
			let card_color = card_stats.color;
			let card_rarity = card_stats.rarity;
			let card_type = card_stats.type;
			// 4: collector number
			let card_ci = removeDuplicateChars(card_stats.color_identity);
			let card_cost = card_stats.cost;
			let card_mv = convertToMV(card_cost);
			//Strip out the lingering [i][/i] and [b][/b] tags while we're searching just in case someone decided to bold something in the
			//middle of their rules text for some reason
			let card_oracle_text = card_stats.rules_text != "" ? card_stats.rules_text.replace(/\[(\/)?([ib])\]/g, "") : card_stats.special_text.replace(/\[(\/)?([ib])\]/g, "");
			let card_power = card_stats.pt.substring(0, card_stats.pt.indexOf('/'));
			let card_toughness = card_stats.pt.substring(card_stats.pt.indexOf('/') + 1);
			let card_shape = card_stats.shape;
			let card_set = card_stats.set;
			let card_loyalty = card_stats.loyalty;
			let card_notes = card_stats.notes;
			let card_artist = card_stats.artist;
			let card_color_2 = "";
			let card_cost_2 = "";
			let card_power_2 = "";
			let card_toughness_2 = "";
			let card_loyalty_2 = ""

			let color_map = new Map([
				["white", "w"],
				["blue", "u"],
				["black", "b"],
				["red", "r"],
				["green", "g"],
				["silver", "i"],
				["azorius", "wu"],
				["dimir", "ub"],
				["rakdos", "br"],
				["gruul", "rg"],
				["selesnya", "gw"],
				["orzhov", "wb"],
				["golgari", "bg"],
				["simic", "gu"],
				["izzet", "ur"],
				["boros", "rw"],
				["esper", "wub"],
				["grixis", "ubr"],
				["jund", "brg"],
				["naya", "rgw"],
				["bant", "gwu"],
				["abzan", "wbg"],
				["sultai", "bgu"],
				["temur", "gur"],
				["jeskai", "urw"],
				["mardu", "rwb"],
			]);

			// two cards in one
			if (card_shape.includes("adventure") || card_shape.includes("double") || card_shape.includes("spli")) {
				card_name = card_name + "	" + card_stats.card_name2;
				card_type = card_type + "	" + card_stats.type2;
				card_oracle_text = card_oracle_text + "	" + (card_stats.rules_text2 != "" ? card_stats.rules_text2.replace(/\[(\/)?([ib])\]/g, "") : card_stats.special_text2.replace(/\[(\/)?([ib])\]/g, ""));
				card_color_2 = card_stats.color2;
				card_cost_2 = card_stats.cost2;
				card_power_2 = card_stats.pt2.substring(0, card_stats.pt2.indexOf('/'));
				card_toughness_2 = card_stats.pt.substring(card_stats.pt.indexOf('/') + 1);
				card_loyalty_2 = card_stats.loyalty2;
			}

			token = token.replaceAll("~", card_name).replaceAll("cardname", card_name).replaceAll('"', '').replaceAll('“', '').replaceAll('”', '');

			const modifierRegex = /[!:<>=]+/g;
			const match = token.match(modifierRegex);

			if (match) {
				const modifier = match[0];
				const term = token.substring(0, token.indexOf(modifier));
				let check = token.substring(token.indexOf(modifier) + modifier.length);

				if (check.charAt(0) == '/') {
					check = check.substring(1);
				}
				if (check.charAt(check.length - 1) == '/') {
					check = check.substring(0, check.length - 1);
				}

				if (color_map.has(check)) {
					check = color_map.get(check);
				}

				// availableTokens = ["mv", "c", "ci", "t", "o", "pow", "tou", "r", "is"]

				/* template
				if (term == "mv")
				{
					if (modifier == "!" || modifier == "=")
					{

					}
					else if (modifier == ":")
					{

					}
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					}
				} */
				if (term == "mv" || term == "cmc") {
					if (modifier == "!" || modifier == "=") {
						return (card_mv == check);
					}
					else if (modifier == ":") {
						return (card_mv == check);
					}
					else if (modifier == "<") {
						return (card_mv < check);
					}
					else if (modifier == ">") {
						return (card_mv > check);
					}
					else if (modifier == "<=") {
						return (card_mv <= check);
					}
					else if (modifier == ">=") {
						return (card_mv >= check);
					}
				}
				if (term == "c" || term == "color" || term == "colour") {
					if (!isNaN(check)) {
						if (modifier == "!" || modifier == "=") {
							return card_color.length == parseInt(check);
						}
						else if (modifier == ":") {
							return card_color.length == parseInt(check);
						}
						else if (modifier == "<") {
							return card_color.length < parseInt(check);
						}
						else if (modifier == ">") {
							return card_color.length > parseInt(check);
						}
						else if (modifier == "<=") {
							return card_color.length <= parseInt(check);
						}
						else if (modifier == ">=") {
							return card_color.length >= parseInt(check);
						}
					}
					else {
						card_color = card_color == "" ? "c" : card_color;
						if (check == "m") {
							if (modifier == "<") {
								return card_color.length < 2;
							}
							else {
								return card_color.length > 1;
							}
						}
						else if (modifier == "!" || modifier == "=") {
							return (card_color.split("").sort().join("") == check.split("").sort().join(""));
						}
						else if (modifier == ":") {
							return hasAllChars(card_color, check);
						}
						else if (modifier == "<") {
							return card_color == "c" || (check.length > card_color.length && hasAllChars(check, card_color));
						}
						else if (modifier == ">") {
							return card_color.length > check.length && hasAllChars(card_color, check);
						}
						else if (modifier == "<=") {
							return card_color == "c" || hasAllChars(check, card_color);
						}
						else if (modifier == ">=") {
							return hasAllChars(card_color, check);
						}
					}
				}
				if (term == "cost" || term == "mana") {
					if (modifier == "!" || modifier == "=" || modifier == ":") {
						card_cost_cleaned = card_cost.replaceAll('{', '').replaceAll('}', '');
						return check == card_cost || check == card_cost_cleaned;
					}
				}
				if (term == "ci" || term == "id") {
					if (!isNaN(check)) {
						card_ci = card_ci == "c" ? "" : card_ci;
						if (modifier == "!" || modifier == "=") {
							return card_ci.length == parseInt(check);
						}
						else if (modifier == ":") {
							return card_ci.length <= parseInt(check);
						}
						else if (modifier == "<") {
							return card_ci.length < parseInt(check);
						}
						else if (modifier == ">") {
							return card_ci.length > parseInt(check);
						}
						else if (modifier == "<=") {
							return card_ci.length <= parseInt(check);
						}
						else if (modifier == ">=") {
							return card_ci.length >= parseInt(check);
						}
					}
					else {
						if (modifier == "!" || modifier == "=") {
							return (card_ci.split("").sort().join("") == check.split("").sort().join(""));
						}
						else if (modifier == ":") {
							return card_ci == "c" || hasAllChars(check, card_ci);
						}
						else if (modifier == "<") {
							return card_ci == "c" || (check.length > card_ci.length && hasAllChars(check, card_ci));
						}
						else if (modifier == ">") {
							return card_ci.length > check.length && hasAllChars(card_ci, check);
						}
						else if (modifier == "<=") {
							return card_ci == "c" || hasAllChars(check, card_ci);
						}
						else if (modifier == ">=") {
							return hasAllChars(card_ci, check);
						}
					}
				}
				if (term == "t" || term == "type") {
					if (modifier == ":") {
						let regex = new RegExp("\\b" + check + "\\b");
						return regex.test(card_type);
					}
					/* unsupported flows
					if (modifier == "!" || modifier == "=")
					{

					}
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					} */
				}
				if (term == "o" || term == "oracle" || term == "text") {
					if (modifier == ":") {
						let regex = new RegExp(check.replaceAll("+", "\\+"));
						return regex.test(card_oracle_text);
					}
					/* unsupported flows
					if (modifier == "!" || modifier == "=")
					{

					}
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					} */
				}
				if (term == "pow" || term == "power") {
					if (modifier == "!" || modifier == "=") {
						return (card_power == check);
					}
					else if (modifier == ":") {
						return (card_power == check);
					}
					else if (modifier == "<") {
						return (card_power < check);
					}
					else if (modifier == ">") {
						return (card_power > check);
					}
					else if (modifier == "<=") {
						return (card_power <= check);
					}
					else if (modifier == ">=") {
						return (card_power >= check);
					}
				}
				if (term == "tou" || term == "toughness") {
					if (modifier == "!" || modifier == "=") {
						return (card_toughness == check);
					}
					else if (modifier == ":") {
						return (card_toughness == check);
					}
					else if (modifier == "<") {
						return (card_toughness < check);
					}
					else if (modifier == ">") {
						return (card_toughness > check);
					}
					else if (modifier == "<=") {
						return (card_toughness <= check);
					}
					else if (modifier == ">=") {
						return (card_toughness >= check);
					}
				}
				if (term == "r" || term == "rarity") {
					rarities = ["common", "uncommon", "rare", "mythic"];
					for (const rarity of rarities) {
						if (rarity.startsWith(check)) {
							check = rarity;
						}
					}
					if (modifier == ":" || modifier == "!" || modifier == "=") {
						return (card_rarity == check);
					}
					else if (modifier == "<") {
						return rarities.includes(card_rarity) && rarities.indexOf(card_rarity) < rarities.indexOf(check);
					}
					else if (modifier == ">") {
						return rarities.includes(card_rarity) && rarities.indexOf(card_rarity) > rarities.indexOf(check);
					}
					else if (modifier == "<=") {
						return rarities.includes(card_rarity) && rarities.indexOf(card_rarity) <= rarities.indexOf(check);
					}
					else if (modifier == ">=") {
						return rarities.includes(card_rarity) && rarities.indexOf(card_rarity) >= rarities.indexOf(check);
					}
				}
				if (term == "e" || term == "set") {
					let set_longname = "";
					for (const set of set_list.sets) {
						if (set.set_code.toLowerCase() == card_set) {
							set_longname = set.set_name.toLowerCase();
							break;
						}
					}
					if (modifier == ":" || modifier == "!" || modifier == "=") {
						return (card_set == check || set_longname.includes(check));
					}
					/* unsupported flows
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					} */
				}
				if (term == "keyword" || term == "kw" || term == "has") {
					if (modifier == ":" || modifier == "!" || modifier == "=") {
						regex_kw1 = new RegExp(`(^|\n|, )${check}[^.]*($|\n|\\()`, "g");
						regex_kw2 = new RegExp(`(^|\n)${check} `, "g");
						return regex_kw1.test(card_oracle_text) || regex_kw2.test(card_oracle_text);
					}
					/* unsupported flows
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					} */
				}
				if (term == "alias") {
					let regex = new RegExp(check.replaceAll("+", "\\+"));
					return regex.test(card_stats.special_text);
				}
				if (term == "f" || term == "format") {
					if (modifier == ":" || modifier == "!" || modifier == "=") {
						for (const set of sets_json.sets) {
							if (set.set_code.toLowerCase() == card_set) {
								formats = ["standard", "modern", "legacy"];
								set_formats = set.formats.toLowerCase().replace(' ', '').split(',');

								for (const format of set_formats) {
									if (formats.includes(format) && formats.includes(check)) {
										if (formats.indexOf(format) < formats.indexOf(check)) {
											return true;
										}
									}
								}

								return set_formats.includes(check);
							}
						}
					}
					return false;
				}
				if (term == "is") {
					if (modifier == ":" || modifier == "!" || modifier == "=") {
						// all of these are implemented individually
						if (check == "permanent") {
							return !card_type.includes("instant") && !card_type.includes("sorcery");
						}
						if (check == "spell") {
							return !card_type.includes("land");
						}
						if (check == "commander") {
							return (card_type.includes("legendary") && card_type.includes("creature")) || card_oracle_text.includes("can be your commander");
						}
						if (check == "hybrid") {
							for (let i = 0; i < card_cost.length - 2; i++) {
								if (card_cost[i] != '{' && card_cost[i] != '}' && card_cost[i + 1] != '{' && card_cost[i + 1] != '}' && !isDecimal(card_cost[i + 1])) {
									return true;
								}
							}
							return false;
						}
						if (check == "sanctum") {
							let regex = new RegExp("((P|p)athbound|(H|h)eir–)");
							if (regex.test(card_oracle_text)) {
								return true;
							} else {
								if (card_type.includes("wonder") || card_type.includes("erysite") || card_type.includes("realm") || card_type.includes("frontier")) {
									return true;
								} else {
									if (card.special_text.includes("sanctum")) {
										return true;
									} else {
										return false;
									}
								}
							}
						}
						if (check == "dfc") {
							return card_shape.includes("double");
						}
						if (check == "mdfc") {
							return card_shape.includes("modal") && card_shape.includes("double");
						} if (check == "tdfc") {
							return (card_shape.includes("transform") || card.rules_text.includes("transform")) && card_shape.includes("double");
						}
						if (check == "played") {
							if (!document.getElementById("get-stats").dataset.ready) {
								do {
									await delay(100);
								}
								while (!document.getElementById("get-stats").dataset.ready);
							}

							if (!all_cards_stats) {
								document.getElementById("get-stats").click();
								all_cards_stats = JSON.parse(localStorage.getItem("info.stats"));
							}

							return isPlayed(all_cards_stats[card.card_name]);
						}
						if (check == "staple") {
							if (!document.getElementById("get-stats").dataset.ready) {
								do {
									await delay(100);
								}
								while (!document.getElementById("get-stats").dataset.ready);
							}

							if (!all_cards_stats) {
								document.getElementById("get-stats").click();
								all_cards_stats = JSON.parse(localStorage.getItem("info.stats"));
							}

							return isStaple(all_cards_stats[card.card_name]);
						}
						if (check == "removal") {
							return isRemoval(card_stats);
						}
						if (check == "ca" || check == "cardadvantage" || check == "draw") {
							return isCA(card_stats);
						}
						if (check == "wipe" || check == "wrath" || check == "boardwipe") {
							return isWipe(card_stats);
						}
						if (check == "wish" || check == "fetch") {
							return isWish(card_stats);
						}
						if (check == "utilityland" || check == "utility land" || check == "utility-land" || check == "utility_land") {
							return isUtilityLand(card_stats);
						}
						if (check == "kindred") {
							return isKindred(card_stats);
						}
						if (check == "recur" || check == "recurrable") {
							return isRecurrable(card_stats);
						}
					}
					/* unsupported flows
					else if (modifier == "<")
					{

					}
					else if (modifier == ">")
					{

					} */
				}
				if (term == "tag") {
					if (modifier == ":" || modifier == "=" || modifier == "!") {
						if (check == "removal") {
							return isRemoval(card_stats);
						}
						if (check == "ca" || check == "cardadvantage" || check == "draw") {
							return isCA(card_stats);
						}
						if (check == "wipe" || check == "wrath" || check == "boardwipe") {
							return isWipe(card_stats);
						}
						if (check == "wish" || check == "fetch") {
							return isWish(card_stats);
						}
						let regex = new RegExp("!tag " + check + "\\b");
						return regex.test(card_notes);
					}
				}
				if (term == "a" || term == "art" || term == "artist") {
					if (modifier == ":" || modifier == "=" || modifier == "!") {
						return card_artist.includes(check);
					}
				}
				if (term == "ft" || term == "flavor" || term == "flavour" || term == "flavortext" || term == "flavourtext") {
					if (modifier == "!" || modifier == "=") {
						return card_stats.flavor_text == check;
					}
					else if (modifier == ":") {
						return card_stats.flavor_text.includes(check);
					}
					else if (modifier == "<") {
						return card_stats.flavor_text < check;
					}
					else if (modifier == ">") {
						return card_stats.flavor_text > check;
					}
				}
				if (term == "lore") {
					if (modifier == "!" || modifier == "=" || modifier == ":") {
						return card_stats.flavor_text.toLowerCase().includes(check) || card_name.includes(check) || card.notes.toLowerCase().includes(check);
					}
				}
				if (term == "designer" || term == "design") {
					if (modifier == "!" || modifier == "=" || modifier == ":") {
						return card_stats.designer.includes(check);
					}
				}
				if (term == "size" || term == "pt") {
					let searched_power = parseInt(check.split("/")[0]);
					let searched_toughness = parseInt(check.split("/")[1]);
					function search_tou(check, modifier, card_toughness) {
						if (modifier == "!" || modifier == "=") {
							return (card_toughness == check);
						}
						else if (modifier == ":") {
							return (card_toughness == check);
						}
						else if (modifier == "<") {
							return (card_toughness < check);
						}
						else if (modifier == ">") {
							return (card_toughness > check);
						}
						else if (modifier == "<=") {
							return (card_toughness <= check);
						}
						else if (modifier == ">=") {
							return (card_toughness >= check);
						}
					}

					function search_pow(check, modifier, card_power) {
						if (modifier == "!" || modifier == "=") {
							return (card_power == check);
						}
						else if (modifier == ":") {
							return (card_power == check);
						}
						else if (modifier == "<") {
							return (card_power < check);
						}
						else if (modifier == ">") {
							return (card_power > check);
						}
						else if (modifier == "<=") {
							return (card_power <= check);
						}
						else if (modifier == ">=") {
							return (card_power >= check);
						}
					}
					return search_pow(searched_power, modifier, card_power) && search_tou(searched_toughness, modifier, card_toughness);
				}
				if (modifier == ":" || modifier == "=" || modifier == "!") {
					let regex = new RegExp(`!tag<${term}> ${check}\\b`);
					return regex.test(card_notes);
				}
			}
			let regex = new RegExp(token.replaceAll("+", "\\+"));
			return (regex.test(card_stats.special_text) && (localStorage.getItem('settings.searchalias') == "On")) || card_name.includes(token);
		} function isDecimal(char) {
			return char >= '0' && char <= '9';
		}

		function isWish(card) {
			const regex = /(reveal|put) (.*?) from your sanctum/gi;

			return regex.test(card.rules_text);
		}

		function isWipe(card) {
			const regex = /(((destroy|exile) (all|each) creatures?)|(deals [1234567890]+? damage to each)|(each ((nonland|permanent|creature|artifact|enchantment|planeswalker|battle|land|kindred|legendary|snow) ?)+ gets [+-][1234567890]+?\/-[1234567890]+?)|((put|return) each ((nonland|permanent|creature|artifact|enchantment|planeswalker|battle|land|kindred|legendary|snow) ?)+ (to its owner['’]s hand|on (the)? ?(top|bottom)|(into its owner['’]s sanctum))))/gi;

			return regex.test(card.rules_text);
		}

		function isCA(card) {
			const regex = /(Clue token|[Ii]nvestigate)|[Dd]raw|[Dd]raft|(play|cast) ([^\n.]+ (from exile|exiled)|(one of )?those cards|them|it this turn|it until)|(graveyard to|into) your hand|\b(?:return\W+(?:\w+\W+){0,5}?to your hand|to your hand\W+(?:\w+\W+){0,5}?return)\b/gi;

			return regex.test(card.rules_text);
		}


		function isRemoval(card) {
			const regex = /((destroy)|(deals [1234567890]+? damage to (any|target|each) (creature|nonplayer|target|planeswalker))|((target|each) (player|opponent) sacrifices?)|(Exile (target|each) ((nonland|permanent|creature|artifact|enchantment|planeswalker|battle|land|kindred|legendary|snow) ?)+)|(fights)|(return (target|each) ((nonland|permanent|creature|artifact|enchantment|planeswalker|battle|land|kindred|legendary|snow) ?)+ to its owner['’]s hand)|(loses all abilities)|(can['’]t attack or block)|(doesn['’]t untap during its controllers untap)|((target|each) (((nonland|permanent|creature|artifact|enchantment|planeswalker|battle|land|kindred|legendary|snow) ?)+) gets [+-][1234567890X]+?\/-[X123456789]+?)|(put (?!card)(.*?) on the (top|bottom)))/gi;

			if (card.rules_text.includes("exile") && card.rules_text.includes("return it to the")) return false;

			return regex.test(card.rules_text);
		}

		function isKindred(card) {
			const regex = /((Aetherborn|Alien|Angel|Antelope|Ape|Archon|Armadillo|Assembly-Worker|Astartes|Atog|Aurochs|Avatar|Azra|Badger|Balloon|Basilisk|Bat|Bear|Beast|Beaver|Beeble|Beholder|Bird|Blinkmoth|Boar|Bringer|Brushwagg|Ctan|Cabybara|Camarid|Camel|Caribou|Carrier|Cat|Centaur|Cephalid|Chimera|Cockatrice|Construct|Coyote|Crab|Crocodile|Custodes|Cyberman|Cyclops|Dalek|Dauthi|Demigod|Demon|Devil|Dinosaur|Djinn|Dog|Dragon|Drake|Dreadnought|Drone|Dryad|Dwarf|Efreet|Egg|Eldrazi|Elemental|Elephant|Elf|Elk|Eye|Faerie|Ferret|Fish|Fox|Fractal|Frog|Fungus|Gargoyle|Germ|Giant|Gith|Glimmer|Gnoll|Gnome|Goat|Goblin|God|Golem|Gorgon|Graveborn|Gremlin|Griffin|Hag|Halfling|Hamster|Harpy|Hellion|Hippo|Hippogriff|Homarid|Homunculus|Horror|Horse|Human|Hydra|Hyena|Illusion|Imp|Incarnation|Inkling|Insect|Jackal|Jellyfish|Juggernaut|Kavu|Kirin|Kithkin|Kobold|Kor|Kraken|Lamia|Lammasu|Leech|Leviathan|Lhurgoyf|Licid|Lizard|Llama|Manticore|Masticore|Merfolk|Metathran|Minotaur|Mite|Mole|Mongoose|Monkey|Moonfolk|Mouse|Mutant|Myr|Nautilus|Necron|Nephilim|Nightmare|Nightstalker|Noggle|Nymph|Octopus|Ogre|Ooze|Orb|Orc|Orgg|Otter|Ouphe|Ox|Oyster|Pangolin|Pegasus|Pentavite|Pest|Phelddagrif|Phoenix|Phyrexian|Pincher|Plant|Possum|Prism|Procupine|Rabbit|Raccoon|Rat|Reflection|Rhino|Robot|Sable|Salamander|Sand|Saproling|Satyr|Scarecrow|Scorpion|Sculpture|Serpent|Servo|Shade|Shapeshifter|Shark|Sheep|Siren|Skeleton|Skunk|Slith|Sliver|Sloth|Slug|Snail|Snake|Soltari|Spawn|Specter|Sphinx|Spider|Spike|Spirit|Splinter|Sponge|Squid|Squirrel|Starfish|Surrakar|Synth|Tentacle|Tetravite|Thalakos|Thopter|Thrull|Tiefling|TimeLord|Toy|Treefolk|Trilobite|Triskelavite|Troll|Turtle|Tyranid|Unicorn|Vampire|Varmint|Vedalken|Viashino|Volver|Wall|Walrus|Weasel|Weird|Werewolf|Whale|Wolf|Wolverine|Wombat|Worm|Wraith|Wurm|Yeti|Zombie|ZuberaAdvisor|Ally|Archer|Archon|Army|Artificer|Assassin|Barbarian|Bard|Beast|Berserker|Carrier|Child|Citizen|Cleric|Clown|Coward|Deserter|Detective|Doctor|Dreadnought|Drone|Druid|Egg|Elder|Employee|Flagbearer|Gamer|Guest|Horror|Incarnation|Inquisitor|Juggernaut|Knight|Leviathan|Mercenary|Minion|Monger|Monk|Mount|Mutant|Mystic|Ninja|Noble|Nomad|Peasant|Performer|Pilot|Pirate|Praetor|Primarch|Processor|Ranger|Rebel|Reflection|Rigger|Rogue|Samurai|Scientist|Scion|Scout|Serf|Shaman|Skeleton|Soldier|Spawn|Spellshaper|Spirit|Survivor|Thopter|Toy|Vampire|Warlock|Warrior|Werewolf|Wizard|Zombie)|creature type)/gi;

			return regex.test(card.rules_text);
		}

		function isRecurrable(card) {
			const re = `((You may cast (this card|${card.card_name}) from your graveyard)|(return (this card|${card.card_name}) from your graveyard)|(put (this card|${card.card_name}) from your graveyard))`;
			const regex = new RegExp(re, "gi");

			return regex.test(card.rules_text);
		}

		function isUtilityLand(card) {
			const regex = /({.}+?): [^a][^d][^d].*/gi;

			return regex.test(card.rules_text) && card.type.includes("land") && !card.card_name.includes("drifting");
		}

		function tokenize(text) {
			let tokens = [];

			for (let i = 0; i < text.length; i++) {
				if (i < text.length - 1) {
					if (text[i + 1] == '/') {
						tokens.push(text.substring(i, i + 3));
						i = i + 2;
					}
					else if (isDecimal(text[i]) && isDecimal(text[i + 1])) {
						tokens.push(text.substring(i, i + 2));
						i = i + 1;
					}
					else {
						tokens.push(text[i]);
					}
				}
				else {
					tokens.push(text[i]);
				}
			}

			return tokens;
		}

		function symbolize(text) {
			//This isn't needed now that the { & } are put into the cost & text by the exporter
			//let tokens = tokenize(text);
			//let symText = "";
			//for (const token of tokens)
			//{
			//	symText = symText + "{" + token + "}";
			//}

			return formatTextHTML(text);
		}

		function formatTextHTML(str) {
			if (!str)
				return "";
			str = str.replace(/[{]([^}]+)[}]/g, function (matched, _1) {
				let letters = _1.toLowerCase()
				return '<span class="mana mana-cost mana-' + letters + '"></span>';
			})
			return str;
		}

		function gridifyCard(card_stats, card_text = false, rotate_card = false, designer_notes = false) {
			const card_name = card_stats.card_name;

			if (displayStyle == "cards-only") {
				return buildImgContainer(card_stats, true, rotate_card);
			}

			const grid = document.createElement("div");
			grid.className = "image-grid";

			grid.appendChild(buildImgContainer(card_stats, false, rotate_card));

			const text = document.createElement("div");
			text.className = "card-text popout";
			text.id = "card-text";

			const name_cost = document.createElement("div");
			name_cost.className = "name-cost";
			name_cost.innerHTML = card_stats.card_name + (card_stats.cost != "" ? '     ' + symbolize(card_stats.cost) : "");
			text.appendChild(name_cost);

			const type = document.createElement("div");
			type.className = "type";
			type.textContent = card_stats.type;
			text.appendChild(type);

			const effect = document.createElement("div");
			effect.className = "effect";
			let card_effects = "";
			if (card_stats.rules_text != "") {
				card_effects = card_stats.rules_text.split("\n");
			}
			else {
				card_effects = card_stats.special_text.split("\n");
			}
			effect.innerHTML += prettifyEffects(card_effects);
			text.appendChild(effect);

			if (card_stats.pt != "") {
				const pt = document.createElement("div");
				pt.className = "pt";
				pt.textContent = card_stats.pt;
				text.appendChild(pt);
			}
			else if (card_stats.loyalty != "") {
				const loyalty = document.createElement("div");
				loyalty.className = "pt";
				loyalty.textContent = "[" + card_stats.loyalty + "]";
				text.appendChild(loyalty);
			}

			if (designer_notes && card_stats.designer_notes != null) {
				const dnotes = document.createElement("div");
				dnotes.className = "designer-notes";
				dnotes.innerHTML = "<u><b>Designer Notes</b></u>";
				dnotes.innerHTML = dnotes.innerHTML + card_stats.designer_notes;
				text.appendChild(dnotes);
			}

			// 13-name	14-color	15-type	16-ci	17-cost	18-ability	19-pt	20-special-text	21-loyalty
			if (card_stats.shape.includes("adventure") || card_stats.shape.includes("double") || card_stats.shape.includes("spli")) {
				const name_cost_2 = document.createElement("div");
				name_cost_2.className = "name-cost";
				name_cost_2.innerHTML = card_stats.card_name2 + (card_stats.cost2 != "" ? '     ' + symbolize(card_stats.cost2) : "");
				text.appendChild(name_cost_2);

				const type_2 = document.createElement("div");
				type_2.className = "type";
				type_2.textContent = card_stats.type2;
				text.appendChild(type_2);

				const effect_2 = document.createElement("div");
				effect_2.className = "effect";
				let card_effects_2 = "";
				if (card_stats.rules_text2 != "") {
					card_effects_2 = card_stats.rules_text2.split("\n");
				}
				else {
					card_effects_2 = card_stats.special_text2.split("\n");
				}
				effect_2.innerHTML += prettifyEffects(card_effects_2);
				text.appendChild(effect_2);

				if (card_stats.pt2 != "") {
					const pt_2 = document.createElement("div");
					pt_2.className = "pt";
					pt_2.textContent = card_stats.pt2;
					text.appendChild(pt_2);
				}
				else if (card_stats.loyalty2 != "") {
					const loyalty = document.createElement("div");
					loyalty.className = "pt";
					loyalty.textContent = "[" + card_stats.loyalty2 + "]";
					text.appendChild(loyalty);
				}
			}

			grid.appendChild(text);

			return grid;
		}

		function buildImgContainer(card_stats, hidden_title = false, rotate_card = false) {
			const imgContainer = document.createElement("div");
			imgContainer.className = "img-container";
			const id = card_stats.set + "-" + card_stats.number + "-" + document.getElementById("display").value;

			const img = document.createElement("img");
			img.className = "card-image";
			img.id = id;
			// (card_stats[13].includes("_") ? card_stats[13] : card_stats[0]) for posterity
			img.src = "/sets/" + card_stats.set + "-files/img/" + card_stats.number + (card_stats.shape.includes("token") ? "t_" : "_") + card_stats.card_name + ((card_stats.shape.includes("double")) ? "_front" : "") + "." + card_stats.image_type;

			const link = document.createElement("a");

			const url = new URL('card', window.location.origin);
			const params = {
				set: card_stats.set,
				num: card_stats.number,
				name: card_stats.card_name
			}
			for (const key in params) {
				url.searchParams.append(key, params[key]);
			}
			link.href = url;

			link.appendChild(img);

			if ((card_stats.shape.includes("spli") || card_stats.type.includes("Battle")) && rotate_card) {
				const rotated_img = document.createElement("img");
				rotated_img.className = "h-img";
				rotated_img.id = "h-img";
				rotated_img.src = img.src;
				rotated_img.style.display = "block";
				img.style.filter = "blur(2px) brightness(0.7)";

				link.appendChild(rotated_img);
			}

			imgContainer.appendChild(link);

			if (card_stats.shape.includes("double")) {
				const imgFlipBtn = document.createElement("button");
				imgFlipBtn.className = "btn";
				imgFlipBtn.onclick = async function () { imgFlip(id, rotate_card); };
				const imgFlipIcon = document.createElement("img");
				imgFlipIcon.className = "img-flip-icon";
				imgFlipIcon.src = '/img/flip.svg';
				imgFlipBtn.appendChild(imgFlipIcon);
				imgContainer.appendChild(imgFlipBtn);
			}

			if (hidden_title) {
				const title = document.createElement("div");
				title.innerText = card_stats.card_name;
				title.className = "hidden-text";
				imgContainer.appendChild(title);
			}

			return imgContainer;
		}

		async function imgFlip(id, rotate_card = false) {
			const img = document.getElementById(id);
			const seconds = 0.15;
			const cardName = img.src;

			img.style.transition = seconds.toString() + "s";
			img.style.transform = "rotateY(90deg)";

			const btn = img.parentElement.parentElement.getElementsByTagName("button")[0];
			btn.style.transition = seconds.toString() + "s";
			btn.style.filter = cardName.includes("_front") ? "invert()" : "";

			await setTimeout(function () {
				const rotated_img = document.getElementById("h-img");

				if (cardName.includes("_front")) {
					img.src = cardName.replace("_front", "_back");
					img.parentElement.parentElement.getElementsByTagName("button")[0].style.filter = "invert()";

					if (rotate_card) {
						rotated_img.style.display = "none";
						img.style.filter = "";
					}
				}
				else {
					img.src = cardName.replace("_back", "_front");
					img.parentElement.parentElement.getElementsByTagName("button")[0].style.filter = "";

					if (rotate_card) {
						rotated_img.style.display = "block";
						img.style.filter = "blur(2px) brightness(0.7)";
					}
				}

				img.style.transition = (seconds * 2).toString() + "s";
				img.style.transform = "rotateY(0deg)";
			}, seconds * 1000);

			await setTimeout(function () {
				console.log("done");
			}, seconds * 1000);
		}

		function prettifyEffects(card_effects) {
			let HTML = "";

			for (let i = 0; i < card_effects.length; i++) {
				let styled_effect = card_effects[i].replace(/\[i\]([^\]]+)\[\/i\]/g, function (matched, _1) {
					return '<i>' + _1 + '</i>'
				}).replace(/\[b\]([^\]]+)\[\/b\]/g, function (matched, _1) {
					return '<b>' + _1 + '</b>'
				})

				HTML += styled_effect;

				if (i != card_effects.length - 1) {
					HTML += "<br>"
				}
			}

			let regexHTML = symbolize(HTML);

			return regexHTML;
		}

		function hasAllChars(strOut, strIn) {
			let retVal = true;

			for (let i = 0; i < strIn.length; i++) {
				if (!strOut.includes(strIn.charAt(i))) {
					retVal = false;
				}
			}

			return retVal;
		}

		function hasNoChars(strOut, strIn) {
			let retVal = true;

			for (let i = 0; i < strIn.length; i++) {
				if (strOut.includes(strIn.charAt(i))) {
					retVal = false;
				}
			}

			return retVal;
		}

		function hasAllAndMoreChars(strOut, strIn) {
			let retVal = true;

			for (let i = 0; i < strIn.length; i++) {
				if (!strOut.includes(strIn.charAt(i))) {
					retVal = false;
				}
			}

			return retVal && (strOut.length > strIn.length);
		}

		document.getElementById("search").addEventListener("keypress", function (event) {
			if (event.key === "Enter") {
				event.preventDefault();
				preSearch(true);
			}
		});

		function previousPage() {
			page = page - 1;
			cardGrid.innerHTML = "";

			let url = (window.location.href.indexOf("page=") == -1 ? new URL(window.location.href) : new URL(window.location.href.substring(0, window.location.href.indexOf("page="))));
			let params = new URLSearchParams(url.search);
			if (page != 0) {
				params.append("page", page + 1);
			}
			history.pushState({}, '', url.pathname + '?' + params.toString());

			for (let i = (pageCount * page); i < Math.min((pageCount * (page + 1)), search_results.length); i++) {
				cardGrid.appendChild(gridifyCard(search_results[i]));
			}

			document.getElementById("nextBtn").disabled = false;
			document.getElementById("nextBtn-footer").disabled = false;
			if (page == 0) {
				document.getElementById("prevBtn").disabled = true;
				document.getElementById("prevBtn-footer").disabled = true;
			}

			document.body.scrollTop = 0; // For Safari
			document.documentElement.scrollTop = 0; // For real browsers
		}

		function nextPage() {
			page = page + 1;

			let url = (window.location.href.indexOf("page=") == -1 ? new URL(window.location.href) : new URL(window.location.href.substring(0, window.location.href.indexOf("page="))));
			let params = new URLSearchParams(url.search);
			params.append("page", page + 1);
			history.pushState({}, '', url.pathname + '?' + params.toString());

			cardGrid.innerHTML = "";

			for (let i = (pageCount * page); i < Math.min((pageCount * (page + 1)), search_results.length); i++) {
				cardGrid.appendChild(gridifyCard(search_results[i]));
			}

			document.getElementById("prevBtn").disabled = false;
			document.getElementById("prevBtn-footer").disabled = false;
			if (search_results.length <= (pageCount * (page + 1))) {
				document.getElementById("nextBtn").disabled = true;
				document.getElementById("nextBtn-footer").disabled = true;
			}

			document.body.scrollTop = 0; // For Safari
			document.documentElement.scrollTop = 0; // For real browsers
		}

		function randomCard() {
			let i = Math.floor(Math.random() * (card_list_arrayified.length + 1));
			let random_card = card_list_arrayified[i];

			const url = new URL('card', window.location.origin);
			const params = {
				set: random_card.set,
				num: random_card.number,
				name: random_card.card_name
			}
			for (const key in params) {
				url.searchParams.append(key, params[key]);
			}

			window.location.href = url;
		}

		function prepareGradients() {
			let defaultGradient = localStorage.getItem("settings.gradient").replace('-', ' ');
			const opt = document.createElement("option");
			opt.value = defaultGradient.replace(' ', '-');
			opt.text = defaultGradient;
			document.getElementById("color-select").appendChild(opt);
			let random_card = localStorage.getItem("settings.gradient").replace('-', ' ');
			const opt_rand = document.createElement("option");
			opt_rand.value = "Random-Card";
			opt_rand.text = "Random Card";

			document.getElementById("color-select").appendChild(opt_rand);
			for (const gradient of gradients) {
				const opt = document.createElement("option");
				opt.value = gradient.name.replace(' ', '-');
				opt.text = gradient.name;
				if (gradient.name != defaultGradient) {
					document.getElementById("color-select").appendChild(opt);
				}
			}

			for (const gradient in card_backgrounds) {
				const opt = document.createElement("option");
				opt.value = gradient.replace(' ', '-');
				opt.text = gradient;
				if (gradient.name != defaultGradient) {
					document.getElementById("color-select").appendChild(opt);
				}
			}

			// setGradient();
		}

		function setGradient(gradient = false) {
			let artistCredit = "";
			if (!gradient) {
				gradient = document.getElementById("color-select").value;
			}

			gradTop = "#000000";
			gradBottom = "#FFFFFF";
			for (const grad of gradients) {
				if (gradient == grad.name.replace(' ', '-')) {
					gradImage = `linear-gradient(to bottom, ${grad.color1}, ${grad.color2})`
				}
			}

			for (const background in card_backgrounds) {
				if (gradient == background.replace(' ', '-')) {
					gradImage = `url("/img/backgrounds/${background.toLowerCase()}.jpg")`;
					artistCredit = card_backgrounds[background][0];
					setTextColor(card_backgrounds[background][1]);
				}
			}

			if (gradient == "Random-Card") {
				const bgs = Object.keys(card_backgrounds);
				const background = bgs[reallyRand(bgs.length)];
				gradImage = `url("/img/backgrounds/${background.toLowerCase()}.jpg")`;
				artistCredit = card_backgrounds[background][0];
				setTextColor(card_backgrounds[background][1]);
			}


			document.body.style.backgroundImage = gradImage;
			localStorage.setItem("settings.gradient", gradient);
			if (document.getElementsByClassName("artist-credit")[0])
				document.getElementsByClassName("artist-credit")[0].remove();
			const credit_text = document.createElement("span");
			credit_text.className = "artist-credit text";
			credit_text.innerText = `background by ${artistCredit}`;
			if (artistCredit && document.getElementById("color-select"))
				document.getElementById("color-select").parentElement.appendChild(credit_text);
		}

		function reallyRand(x, seed = false) {
			const date = new Date();
			seed = seed ? seed : date.getUTCFullYear() * 10000 +
				date.getUTCMonth() * 100 +
				date.getUTCDate();

			const a = 1103515245;
			const c = 12345;
			const m = Math.pow(2, 31);

			let randomNumber = (a * seed + c) % m;
			randomNumber = randomNumber / m;

			return Math.floor(randomNumber * x);
		}

		function setTextColor(c = false) {
			if (c) {
				localStorage.setItem("settings.textcolor", c);
			}
			document.getElementById('text-style').innerHTML = `.text { color: ${localStorage.getItem('settings.textcolor')} }`;
			document.getElementById('text-style').innerHTML += `\n.text-bg { background-color: ${localStorage.getItem('settings.textcolor')} }`;
		}

		function isPlayed(stats) {
			const playrate = parseFloat(stats.playrate_general[1].split("%")[0]);
			return playrate > 3;
		}

		function isStaple(stats) {
			const playrate = parseFloat(stats.playrate_general[1].split("%")[0]);
			const playrate_event = parseFloat(stats.playrate_event[1].split("%")[0]);
			const winrate = parseFloat(stats.winrate[1].split("%")[0]);
			console.log(stats.playrate_event);
			return (playrate > 10 && winrate > 40 && playrate_event > 10);
		}

		modal = document.getElementById("modal-container");
		window.onclick = function (event) {
			if (event.target == modal) {
				document.getElementById('modal-container').style.display = 'none';
			}
		}

		const search_tips = `"t", "type"
Search the card type of a card.
"c", "color", "colour"
Search the colours of the card. the colours are "w", "white", "u", "blue", "b", "black", "r", "red", "g", "green", "i", "silver".
"p", "power"
Search for a cards base power.
"t", "toughness"
Search for a cards base toughness.
":" is 'includes', "=" and "!" are "exact", "<" is "less than", ">" is "greater than".
"<=" gives you all things that include at least one or more of the search. For example, if you search "c<=ubg", you will get all blue, black, and green cards, as well as colourless cards. 
"=>" gives you all things that include all or more of the search. For example, if you search "c>=ubg", you will get all cards that are at minimum blue, black, and green.
"size", "pt"
Search for a cards specific base power and toughness. For example, searching for "size:4/4" will yield all cards with base power and toughness "4/4".
"mv", "cmc"
Search for a cards mana value, or converted mana cost.
"mana", "cost"
Search for a cards specific mana cost. for example, you can search for "mana=2ww" to find all cards with that specific mana cost.
"ci", "id"
Search for a cards colour identity. colour identity includes
"o", "oracle", "text"
Search for text within the cards available. To search for a string of text, surround your search with "". For example, [o:"{T}: Add {G}"] searches for every card that could add green mana.
"r", "rarity"
Search for a cards rarity.
"e", "set"
Search for cards from a specific set.
"kw", "has", "keyword"
Search for a keyword among cards. For example, "kw:luminous" will find all cards that have luminous within their card text.
"alias"
Search within aliases of cards. For example, "alias:gradius" will find "Gradius" and "Gradius' Option".
"is"
Search for cards that fall within a specialized grouping. The groupings include: = permanent = spell = commander = hybrid = sanctum = dfc = mdfc = tdfc = removal = cardadvantage = boardwipe = utilityland = recurrable = kindred = wish = played = staple =
"tag"
Search for specialized tags that are added to cards via the card notes. For example, "tag:fascism" will find all cards that are tagged with fascism, such as all the cards that mention clan mordel.
"a", "art", "artist"
Search for artists listed on the cards.
"ft", "flavor", "flavour"
Search through the flavour text within cards.
"lore"
Search through cards flavour text, name, and card notes for a word or name available.
"designer"
Search for the designer of cards within the selection. For example, "designer:TVP" will find all cards that were designed by TVP.
"lairnumber"
Search for secret lairs by their release order. For example, "lairnumber:1" will find all cards available within the first secret lair.
"lairname"
Search for a secret lair by its name. For example, [lairname:"the hours"] finds all cards released within The Hours secret lair.
"champion"
Search for cards that were made into champion promo's by a specific user. For example, searching "champion:kogane" will find all cards that user kogane has made into champion promo's by winning in various events.`;

		function formatText(text) {
			let new_text = text;
			new_text = new_text.replaceAll(/"(.*?)"/g, function (_1) {
				return "<b>" + _1 + "</b>";
			});
			new_text = new_text.replaceAll(/\"([^ {]+?[:=][^ ]+?)\"/g, function (_1, _2) {
				return "<a target=\"blank\" href=\"/search?search=" + encodeURI(_2.replaceAll(/<.+?>/g, "")) + "\">" + _1 + "</a>";
			});
			new_text = new_text.replaceAll(/\[(.+?[:=].+?)\]/g, function (_1, _2) {
				return "<a target=\"blank\" href=\"/search?search=" + encodeURI(_2.replaceAll("<b>", "").replaceAll("</b>", "")) + "\">" + _1 + "</a>";
			});
			new_text = new_text.replaceAll(/^<b>/gm, "<hr><b>");
			return new_text.replaceAll("\n", "<br>");
		}

		function goToOnboard() {
			const modal_container = document.getElementById("modal-container");
			const modal_content = document.getElementById("modal-content");
			modal_container.style.display = "block";
			modal_content.innerHTML = formatText(search_tips);
		}

	</script>
	<script type="module">
		// Import the functions you need from the SDKs you need
		import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js";
		import { setDoc, addDoc, updateDoc, doc, collection, getFirestore, query, where, getDocs, getDoc } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js";
		// TODO: Add SDKs for Firebase products that you want to use
		// https://firebase.google.com/docs/web/setup#available-libraries

		// Your web app's Firebase configuration
		// For Firebase JS SDK v7.20.0 and later, measurementId is optional
		const firebaseConfig = {
			apiKey: "AIzaSyCPurnKVn2caCn3L-gKF2tMFwWur73YAuw",
			authDomain: "voyager-78e30.firebaseapp.com",
			projectId: "voyager-78e30",
			storageBucket: "voyager-78e30.firebasestorage.app",
			messagingSenderId: "411191248476",
			appId: "1:411191248476:web:591349be169d823e5f8899",
			measurementId: "G-TQ1L48F25M"
		};

		// Initialize Firebase
		const app = initializeApp(firebaseConfig);
		const db = getFirestore(app);
		let username = "";
		let password = "";
		let sessionid = localStorage.getItem('settings.session');
		let decks = {};
		const events = ["GP1", "League"];
		let user_data;
		let card_list;
		let q;
		let all_users_docs;
		let all_decks = [];
		let all_user_decks = [];
		let all_event_decks = [];
		let all_users = [];
		let all_events_docs;
		let all_events = [];

		function getCardStats() {
			const stats = {};
			for (const card of card_list_arrayified) {
				let num_decks = 0;
				let total_wins = 0;
				let total_games = 0;
				let num_event_decks = 0;
				let num_user_decks = 0;

				for (const event of all_events) {
					if (event.name.includes("League")) continue;
					const swiss = JSON.parse(event.rounds).swiss;
					const decks = JSON.parse(event.decks);
					let players_with_card = [];
					for (const player in decks) {
						const deck = decks[player];
						const decklist = atob(deck.url.split(';')[1].split('&main')[0]);
						for (const line of decklist.split("\n")) {
							if (line.substring(line.indexOf(" ") + 1, line.length) == card.card_name) {
								players_with_card.push(player);
								break;
							}
						}
					}
					for (const round_name in swiss) {
						const round = swiss[round_name];
						for (const game of round) {
							const p1 = Object.keys(game)[0];
							const p2 = Object.keys(game)[1];

							const p1_score = parseInt(game[p1]);
							const p2_score = parseInt(game[p2]);

							let winner = 0;
							if (p1_score > p2_score)
								winner = p1;
							if (p1_score < p2_score)
								winner = p2;

							if (players_with_card.includes(p1)) {
								if (winner == p1) {
									total_wins++;
								}
								if (winner != 0)
									total_games++;
							}
							if (players_with_card.includes(p2)) {
								if (winner == p2) {
									total_wins++;
								}
								if (winner != 0)
									total_games++;
							}
						}
					}
				}

				for (const deck of all_decks) {
					const decklist = atob(deck.url.split(';')[1].split('&main')[0]);
					for (const line of decklist.split("\n")) {
						if (line.substring(line.indexOf(" ") + 1, line.length) == card.card_name) {
							num_decks += 1;
							if (deck.event)
								num_event_decks++;
							else
								num_user_decks++;
						}
					}
				}

				let winrate = ((total_wins / total_games) * 100).toFixed(2).toString() + "%";
				winrate = winrate.replace("NaN%", "No Data");
				const playrate_event_text = ((num_event_decks / event_decks_count) * 100).toFixed(2).toString() + "%";
				const playrate_user_text = ((num_user_decks / user_decks_count) * 100).toFixed(2).toString() + "%";
				const playrate_text = ((num_decks / all_decks.length) * 100).toFixed(2).toString() + "%";

				stats[card.card_name] = {
					winrate: ["GP Winrate", winrate],
					playrate_event: ["Event Playrate", playrate_event_text],
					playrate_user: ["User Playrate", playrate_user_text],
					playrate_general: ["Overall Playrate", playrate_text]
				}
			}

			localStorage.setItem("info.stats", JSON.stringify(stats));
		}

		q = query(collection(db, "events"));
		all_events_docs = await getDocs(q);

		q = query(collection(db, "users"));
		all_users_docs = await getDocs(q);

		all_events_docs.forEach((doc) => {
			const data = doc.data();
			all_events.push(data);
			for (const user in JSON.parse(data.decks)) {
				let deck = JSON.parse(data.decks)[user];
				all_event_decks.push({ ...deck, "user": user, "event": true });
				all_decks.push({ ...deck, "user": user, "event": true });
			}
		});

		all_users_docs.forEach((doc) => {
			const data = doc.data();
			for (const deck of JSON.parse(data.decks)) {
				all_user_decks.push({ ...deck, "user": data.username, "event": false });
				all_decks.push({ ...deck, "user": data.username, "event": false });
			}
		});

		let event_decks_count = 0;
		let user_decks_count = 0;

		for (const deck of all_decks) {
			if (deck.event) {
				event_decks_count++;
			}
			else {
				user_decks_count++;
			}
		}

		document.getElementById("get-stats").dataset.ready = true;
		document.getElementById("get-stats").addEventListener("click", getCardStats);

	</script>
</body>

</html>