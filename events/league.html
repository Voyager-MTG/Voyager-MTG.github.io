<html>

<head>
	<title>League</title>
	<link rel="icon" type="image/x-icon" href="/img/favicon.png">
	<link rel="stylesheet" href="src/css/mana.css">
	<link rel="stylesheet" href="/src/css/header.css">
	<link rel="stylesheet" href="/src/css/theme.css">
	<link rel="stylesheet" href="/src/css/modal.css">
	<link rel="stylesheet" href="/src/css/tab.css">
	<link rel="stylesheet" href="/src/css/deck-container.css">
	<link rel="stylesheet" href="/src/css/pages/league.css">
</head>

<body>
	<div class="header">
		<div class="search-grid">
			<a href="/"><img class="sg-logo" src="/img/banner.png"></a>
			<img class="sg-icon" src="/img/header/search.png">
			<input type="text" inputmode="search" placeholder="Search ..." name="search" id="search" spellcheck="false"
				autocomplete="off" autocorrect="off" spellcheck="false">
			<a href="/all-sets"><img src="/img/header/sets.png" class="sg-icon">Sets</a>
			<a href="/deckbuilder"><img src="/img/header/deck.png" class="sg-icon">Deckbuilder</a>
			<a onclick="randomCard()"><img src="/img/random.png" class="sg-icon">Random</a>
			<div class="community"><a href="/community" id="account-link"><img src="/img/header/community.png"
						class="sg-icon">Community<b>â®Ÿ</b></a>
				<div class="community-dropdown">
					<a href="/community?tab=users" class="community-dropdown-item"><img class="dropdown-icon"
							src="/img/header/community.png">Users</a>
					<a href="/community?tab=decks" class="community-dropdown-item"><img class="dropdown-icon"
							src="/img/header/deck.png">Decks</a>
					<a href="/community?tab=events" class="community-dropdown-item"><img class="dropdown-icon"
							src="/img/swords.png">Events</a>
					<a href="/community?tab=cards" class="community-dropdown-item"><img class="dropdown-icon"
							src="/img/header/sets.png">Cards</a>
				</div>
			</div>
			<a href="/settings" id="account-link"><img src="/img/header/settings.png" class="sg-icon"></a>
			<a href="/account" id="account-link"><img src="/img/header/account.png" class="sg-icon"></a>
		</div>
	</div>
	<div class="selects" id="selects">
		<select id="color-select" onchange="setGradient()">
		</select>
	</div>
	<div class="page-container">
		<div class="tab-select" id="tab-select">
			<div class="tab-btn-active tab-btn" id="games-tab-select" onclick="changeTab('games')">
				<img src="/img/swords.png" class="tab-switch-icon">
				<span>Games</span>
			</div>
			<div class="tab-btn" id="decklists-tab-select" onclick="changeTab('decklists')">
				<img src="/img/header/deck.png" class="tab-switch-icon">
				<span>Decks</span>
			</div>
			<div class="tab-btn" id="runs-tab-select" onclick="changeTab('runs')">
				<img src="/img/trophy.png" class="tab-switch-icon">
				<span>Runs</span>
			</div>
		</div>
		<div class="main-tab" id="main-tab">
			<div class="decks-tab" id="decklists"></div>
			<div class="rounds-tab" id="games"></div>
			<div class="runs-tab" id="runs"></div>
		</div>
	</div>
	<div id="modal-container">
		<div id="modal-content" class="popout">
			<span class="close"
				onclick="document.getElementById('modal-container').style.display = 'none';">&times;</span>
		</div>
	</div>
	<script src="/src/js/background.js"></script>
	<script>
		let gradients = null;
		let raw_gradients = null;
		let gradTop = null;
		let gradBottom = null;
		modal = document.getElementById("modal-container");
		window.onclick = function (event) {
			if (event.target == modal) {
				document.getElementById('modal-container').style.display = 'none';
			}
		}



		document.getElementById("search").addEventListener("keypress", function (event) {
			if (event.key === "Enter") {
				event.preventDefault();
				const url = new URL('search', window.location.origin);
				url.searchParams.append('search', document.getElementById("search").value);
				window.location.href = url;
			}
		});
		function randomCard() {
			let i = Math.floor(Math.random() * (card_list_arrayified.length + 1));
			let random_card = card_list_arrayified[i];

			const url = new URL('card', window.location.origin);
			const params = {
				set: random_card.set,
				num: random_card.number,
				name: random_card.card_name
			}
			for (const key in params) {
				url.searchParams.append(key, params[key]);
			}

			window.location.href = url;
		}

		function closeModal() {
			document.getElementById("modal-container").style.display = "none";
		}

		function changeTab(tab_name) {
			document.getElementById(tab_name).style.display = "grid";
			document.getElementById(tab_name + "-tab-select").className = "tab-btn tab-btn-active"
			for (const child of document.getElementById("main-tab").children) {
				if (child.id != tab_name) {
					child.style.display = "none";
				}
			}
			for (const child of document.getElementById("tab-select").children) {
				if (child.id != tab_name + "-tab-select") {
					child.className = "tab-btn";
				}
			}
		}
	</script>
	<script type="module">
		// Import the functions you need from the SDKs you need
		import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js";
		import { setDoc, addDoc, updateDoc, doc, collection, getFirestore, query, where, getDocs, getDoc } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js";
		// TODO: Add SDKs for Firebase products that you want to use
		// https://firebase.google.com/docs/web/setup#available-libraries

		// Your web app's Firebase configuration
		// For Firebase JS SDK v7.20.0 and later, measurementId is optional
		const firebaseConfig = {
			apiKey: "AIzaSyCPurnKVn2caCn3L-gKF2tMFwWur73YAuw",
			authDomain: "voyager-78e30.firebaseapp.com",
			projectId: "voyager-78e30",
			storageBucket: "voyager-78e30.firebasestorage.app",
			messagingSenderId: "411191248476",
			appId: "1:411191248476:web:591349be169d823e5f8899",
			measurementId: "G-TQ1L48F25M"
		};

		const color_bgs = {
			white: "#"
		}

		// Initialize Firebase
		const app = initializeApp(firebaseConfig);
		const db = getFirestore(app);
		let username = "";
		let password = "";
		let sessionid = localStorage.getItem('settings.session');
		let decks = {};
		// const events = ["GP1", "League "];
		// console.log

		if (sessionid) {
			await getDoc(doc(db, 'sessions', sessionid)).then(docSnap => {
				let data = docSnap.data();
				username = data.username;
				password = data.password;
			});
		}

		let user_data;
		let event_data;
		const urlParams = new URLSearchParams(window.location.search);
		const event = "League";

		// await getDoc(doc(db, COLLECTION, DOC)).then(docSnap => {})
		// docSnap.data()
		// updateDoc(doc(db, COLLECTION, DOC), {k: v, k2: v2, ...})
		await getDoc(doc(db, 'users', username)).then(async docSnap => {
			user_data = docSnap.data();
		});
		await getDoc(doc(db, 'events', event)).then(async docSnap => {
			event_data = docSnap.data();
		});

		let card_list;
		let card_list_arrayified;
		await fetch('/lists/all-cards.json')
			.then(response => response.json())
			.then(json => {
				card_list = json;
			}).catch(error => console.error('Error:', error));

		card_list_arrayified = card_list.cards;
		// console.log(card_list_arrayified);    

		async function reload() {
			document.getElementById("main-tab").innerHTML = `<div class="decks-tab" id="decklists"></div><div class="rounds-tab" id="games"></div><div class="runs-tab" id="runs"></div>`;
			makeDecksTab();
			makeGamesTab();
			makeRunsTab();
		}

		async function makeRunsTab() {
			const container = document.getElementById("runs");
			const unclaimed = getUnclaimedMatches();
			console.log(unclaimed);

			const runs_top = document.createElement("div");
			runs_top.className = "runs-top";

			const new_run = document.createElement("button");
			new_run.className = "new-run-btn";
			new_run.innerText = "New Run";
			new_run.onclick = openDeckSelect;

			const unclaimed_notif = document.createElement("div");
			unclaimed_notif.className = "unclaimed-notif text";
			unclaimed_notif.innerText = `You have ${unclaimed.number} unclaimed matches. Click here to allocate them to runs.`;
			unclaimed_notif.onclick = () => {
				openUnclaimedModal(unclaimed);
			};
			unclaimed_notif.style.display = unclaimed.number == 0 ? "none" : "";

			runs_top.appendChild(unclaimed_notif);
			runs_top.appendChild(new_run);
			container.appendChild(runs_top);
			container.appendChild(gridifyRuns());
		}

		function getUnclaimedMatches() {
			let games = [];
			let id = 0;
			for (const match of JSON.parse(event_data.games)) {
				if (Object.keys(match).includes(user_data.username)) {
					if (match[Object.keys(match)[0]].includes("unclaimed") || match[Object.keys(match)[1]].includes("unclaimed"))
						games.push([match, id]);
				}
				id++;
			}

			return { games: games, number: games.length };
		}

		function openUnclaimedModal(unclaimed) {
			document.getElementById("modal-content").innerHTML = '<span class="close" onclick="closeModal()">&times;</span>';
			document.getElementById("modal-container").style.display = "block";

			for (const match_data of unclaimed.games) {
				const match = match_data[0];
				const match_id = match_data[1];
				const match_container = document.createElement("div");
				match_container.className = "unclaimed-match-container text";
				const p1 = Object.keys(match)[0];
				const p2 = Object.keys(match)[1];
				match_container.innerText = `${p1} ${match[p1][1]}-${match[p2][1]} ${p2}`;
				match_container.onclick = () => {
					document.getElementById("modal-content").innerHTML = '<span class="close" onclick="closeModal()">&times;</span>';
					document.getElementById("modal-content").appendChild(gridifyRuns(match_data));
				}

				document.getElementById("modal-content").appendChild(match_container);
			}
		}

		function gridifyRuns(unclaimed_matches = false) {
			const runs = JSON.parse(event_data.runs)[user_data.username];

			const content_container = document.createElement("div");
			content_container.className = "runs-container";

			for (const run of runs) {
				const deck_ele = gridifyDeck(run.deck);
				deck_ele.appendChild(runStatsHTML(run));

				if (unclaimed_matches) {
					deck_ele.onclick = () => {
						const run_id = runs.indexOf(run);

						const match_id = unclaimed_matches[1];
						const match = unclaimed_matches[0];

						const player = Object.keys(match)[0];
						const opponent = Object.keys(match)[1];

						let new_runs = JSON.parse(event_data.runs);
						let new_matches = JSON.parse(event_data.games);

						new_runs[user_data.username][run_id].matches.push(match_id);
						new_matches[match_id][player][0] = run_id;
						new_matches[match_id][opponent][0] = run_id;

						updateDoc(doc(db, "events", event), {
							runs: JSON.stringify(new_runs),
							games: JSON.stringify(new_matches)
						});

						document.getElementById("modal-container").style.display = "none";

						alert("Match claimed!");

						reload();
					}
				} else {
					deck_ele.onclick = () => {
						document.getElementById("modal-content").innerHTML = `<span class="close" onclick="document.getElementById('modal-container').style.display = 'none';">&times;</span>`;

						let deck_header = document.createElement("span");
						deck_header.className = "deck-window-header";
						deck_header.innerText = user_data.username + "'s " + run.deck.name;

						document.getElementById("modal-content").appendChild(deck_header);
						document.getElementById("modal-content").appendChild(deckHTML(run.deck, card_list_arrayified));

						document.getElementById("modal-container").style.display = 'block';
					}
				}

				content_container.appendChild(deck_ele);
			}

			return content_container;
		}

		function runStatsHTML(run) {
			const matches = run.matches;
			const record = [0, 0];
			console.log("matches", matches);

			for (const match_id of matches) {
				const match = JSON.parse(event_data.games)[match_id];
				console.log(matches[9])
				const won_match = parseInt(match[user_data.username][1]) >= 2;
				console.log("stats", match);

				record[won_match ? 0 : 1]++;
			}

			const record_ele = document.createElement("span");
			record_ele.innerText = `${record[0]}-${record[1]}`;
			record_ele.className = "run-record";

			return record_ele;
		}

		function openDeckSelect() {
			document.getElementById("modal-content").innerHTML = '<span class="close" onclick="closeModal()">&times;</span>';
			document.getElementById("modal-container").style.display = "block";

			const content_container = document.createElement("div");
			content_container.className = "deck-select-container";
			content_container.id = "deck-select-container";

			const deck_search_input = document.createElement("input");
			deck_search_input.className = "new-run-search-input";
			deck_search_input.placeholder = "Search decks...";
			deck_search_input.id = "new-run-search-input";
			deck_search_input.onkeyup = runSearch;

			document.getElementById("modal-content").appendChild(deck_search_input);
			document.getElementById("modal-content").appendChild(content_container);

			runSearch();
		}

		function runSearch() {
			const decks = user_data.decks;
			const search_terms = document.getElementById("new-run-search-input").value.matchAll(/(\[\[.*?\]\]|\S+)/g);
			let search_terms_arrayified = [];
			let search_results = [];

			for (const t of search_terms) {
				search_terms_arrayified.push(t);
			}

			if (search_terms_arrayified.length == 0) search_terms_arrayified = [["", ""]];

			for (const deck of decks) {
				const decklist = atob(deck.url.split(";")[1].split("&main")[0]).toLowerCase();
				for (const term_ of search_terms_arrayified) {
					const term = term_[0];
					console.log(term);
					if (term.includes("[[") && term.includes("]]")) {
						if (decklist.includes(term.split("[[")[1].split("]]")[0].toLowerCase())) {
							search_results.push(deck);
						}
					}
					else if (deck.name.toLowerCase().includes(term.toLowerCase())) {
						search_results.push(deck);
					}
				}
			}

			document.getElementById("deck-select-container").innerHTML = "";

			for (const deck of search_results) {
				const deck_ele = gridifyDeck(deck);
				deck_ele.onclick = () => {
					const new_runs = JSON.parse(event_data.runs);
					new_runs[user_data.username] = new_runs[user_data.username] ? new_runs[user_data.username] : [];
					new_runs[user_data.username].push({ deck: deck, matches: [] })
					updateDoc(doc(db, "events", event), {
						runs: JSON.stringify(new_runs)
					});
					alert("Created new run!");
					document.getElementById("modal-container").style.display = "none";
					reload();
				}
				document.getElementById("deck-select-container").appendChild(deck_ele);
			}
		}

		function gridifyDeck(deck) {
			const container = document.createElement("div");
			container.className = "deck-container";
			const preview_img = document.createElement("img");
			let card_stats;
			for (const card of card_list_arrayified) {
				if (deck.previewimg == card.card_name) {
					card_stats = card;
					break;
				}
			}
			preview_img.src = "/sets/" + card_stats.set + "-files/img/" + card_stats.number + (card_stats.shape.includes("token") ? "t_" : "_") + card_stats.card_name + ((card_stats.shape.includes("double")) ? "_front" : "") + "." + card_stats.image_type;
			preview_img.className = "deck-preview-img";
			// preview_img.onclick = function() {
			//     window.location.href = `/deckbuilder?deck=${deck.user}-${encodeURI(deck.name)}`
			// }
			const deck_name = document.createElement("div");
			deck_name.className = "deck-name";
			deck_name.innerText = deck.name;

			container.appendChild(deck_name);
			container.appendChild(preview_img);
			return container;
		}

		function makeDecksTab() {
			// console.log(card_list_arrayified);
			const decks = event_data.decks;
			for (const deck of decks) {
				let user = deck.user;
				let full_deck_container = document.createElement('div');
				full_deck_container.className = "full-deck-container";
				let deck_container = document.createElement('div');
				deck_container.className = "deck-container";
				let colors_container = document.createElement('div');
				colors_container.className = "colors-container";
				let card_stats;
				let deck_preview = document.createElement('img');
				for (const card of card_list_arrayified) {
					if (deck.previewimg == card.card_name) {
						card_stats = card;
						break;
					}
				}

				if (!card_stats) {
					deck_preview.src = "/img/card_back.png"
				} else {
					deck_preview.src = "/sets/" + card_stats.set + "-files/img/" + card_stats.number + (card_stats.shape.includes("token") ? "t_" : "_") + card_stats.card_name + ((card_stats.shape.includes("double")) ? "_front" : "") + "." + card_stats.image_type;
				}
				deck_preview.src = "/sets/" + card_stats.set + "-files/img/" + card_stats.number + (card_stats.shape.includes("token") ? "t_" : "_") + card_stats.card_name + ((card_stats.shape.includes("double")) ? "_front" : "") + "." + card_stats.image_type;
				deck_preview.onclick = function () {
					document.getElementById("modal-content").innerHTML = `<span class="close" onclick="document.getElementById('modal-container').style.display = 'none';">&times;</span>`;
					let deck_header = document.createElement("span");
					deck_header.className = "deck-window-header";
					deck_header.innerText = user + "'s " + deck.name;
					document.getElementById("modal-content").appendChild(deck_header);
					document.getElementById("modal-content").appendChild(deckHTML(deck, card_list_arrayified));
					document.getElementById("modal-container").style.display = 'block';
				}
				deck_preview.className = "deck-preview-img";
				let deck_name = document.createElement('div');
				deck_name.className = "deck-name";
				deck_name.innerText = user + "'s " + deck.name;
				let deck_btns = document.createElement('div');
				deck_btns.className = "deck-buttons";
				let deck_link = document.createElement('a');
				deck_link.href = `/deckbuilder?edeck=${event}-${deck.name}`;
				deck_link.innerText = "Deckbuilder";
				deck_link.className = "deck-link-green deck-icon-shadow";
				deck_link.target = "_blank";
				let deck_edit_icon = document.createElement('img');
				deck_edit_icon.src = "/img/edit.png";
				deck_edit_icon.className = "deck-icon-green";
				deck_link.appendChild(deck_edit_icon);
				let deck_link2 = document.createElement('span');
				deck_link2.innerText = "View";
				deck_link2.className = "deck-link-blue deck-icon-shadow";
				let deck_edit_icon2 = document.createElement('img');
				deck_edit_icon2.src = "/img/show-white.png";
				deck_edit_icon2.className = "deck-icon-blue";
				deck_link2.onclick = function () {
					document.getElementById("modal-content").innerHTML = `<span class="close" onclick="document.getElementById('modal-container').style.display = 'none';">&times;</span>`;
					let deck_header = document.createElement("span");
					deck_header.className = "deck-window-header";
					deck_header.innerText = user + "'s " + deck.name;
					document.getElementById("modal-content").appendChild(deck_header);
					document.getElementById("modal-content").appendChild(deckHTML(deck, card_list_arrayified));
					document.getElementById("modal-container").style.display = 'block';
				}
				deck_link2.appendChild(deck_edit_icon2);
				if (deck.colors) {
					for (const color of deck.colors) {
						let color_ele = document.createElement('img');
						color_ele.src = `/img/mana/mana_${color}.png`;
						color_ele.className = "mana-img";
						colors_container.appendChild(color_ele);
					}
				}
				deck_btns.appendChild(deck_link);
				deck_btns.appendChild(deck_link2);
				deck_container.appendChild(deck_name);
				deck_container.appendChild(deck_preview);
				deck_container.appendChild(deck_btns);
				full_deck_container.appendChild(deck_container);
				if (deck.colors) full_deck_container.appendChild(colors_container);
				if (deck.colors) {
					document.getElementById("decklists").appendChild(full_deck_container);
				} else {
					document.getElementById("decklists").appendChild(deck_container);
				}
			}
		}

		function deckHTML(deck, card_list) {
			let card_categories = { "creature": "", "planeswalker": "", "instant": "", "sorcery": "", "artifact": "", "enchantment": "", "land": "", "sideboard": "", "sanctum": "" };
			const text = atob(deck.url.split(';')[1].split('&main')[0]);
			let sideboard = [];
			let sb_cards = false;
			let sc_cards = false;
			let count;
			let card_name;
			let card_list_arrayified = card_list;

			const lines = text.split('\n');

			let deck_map = new Map();
			let sb_map = new Map();
			let sc_map = new Map();

			for (const line of lines) {
				if (line == 'sideboard' || line == '') // '' for Draftmancer files
				{
					sb_cards = true;
				}
				else if (line == 'sanctum' || (sb_cards && line == '')) // '' for Draftmancer files
				{
					sc_cards = true;
					sb_cards = false;
				}
				else if (!sb_cards && !sc_cards) {
					// get the count and card name
					count = parseInt(line.substring(0, line.indexOf(' ')));
					card_name = line.substring(line.indexOf(' ') + 1);

					if (deck_map.has(card_name)) // if the deck has card name, add the new value, if it doesnt, set the value to stop keyerrors
					{
						deck_map.set(card_name, deck_map.get(card_name) + count);
					}
					else {
						deck_map.set(card_name, count);
					}
				}
				else if (sb_cards) // sideboard cards, do the same thing but with sb_map
				{
					count = parseInt(line.substring(0, line.indexOf(' ')));
					card_name = line.substring(line.indexOf(' ') + 1);

					if (sb_map.has(card_name)) {
						sb_map.set(card_name, sb_map.get(card_name) + count);
					}
					else {
						sb_map.set(card_name, count);
					}
				} else if (sc_cards) // sanctum cards, do the same thing but with sc_map
				{
					count = parseInt(line.substring(0, line.indexOf(' ')));
					card_name = line.substring(line.indexOf(' ') + 1);

					if (sc_map.has(card_name)) {
						sc_map.set(card_name, sc_map.get(card_name) + count);
					}
					else {
						sc_map.set(card_name, count);
					}
				}
			}

			// initialize card types (and sideboard)
			let deck_cards = new Map([
				['land', new Map([])],
				['creature', new Map([])],
				['instant', new Map([])],
				['planeswalker', new Map([])],
				['artifact', new Map([])],
				['enchantment', new Map([])],
				['sorcery', new Map([])],
				['battle', new Map([])],
				['sideboard', new Map([])],
				['sanctum', new Map([])]
			]);

			for (const [card, copies] of deck_map) {
				let card_type;
				// loop through each card in deck_map and get the cardtype
				for (const card2 of card_list_arrayified) {
					if (card2.card_name == card) {
						card_type = card2.type.toLowerCase();
						break;
					}
				}

				for (const [key, map] of deck_cards) {
					if (card_type.includes(key)) {
						map.set(card, copies)
						break;
					}
				}
			}
			for (const [card, copies] of sb_map) {
				for (const [key, map] of deck_cards) {
					if (key == 'sideboard') {
						map.set(card, copies)
						break;
					}
				}
			}
			for (const [card, copies] of sc_map) {
				for (const [key, map] of deck_cards) {
					if (key == 'sanctum') {
						map.set(card, copies)
						break;
					}
				}
			}
			let total_copies = { "creature": 0, "planeswalker": 0, "instant": 0, "sorcery": 0, "artifact": 0, "enchantment": 0, "land": 0, "sideboard": 0, "sanctum": 0 };
			for (const [k, map] of deck_cards) {
				for (const [card, num] of map) {
					card_categories[k] += `<span class="card-in-deck">${num}x ${card}</span><br>`;
					total_copies[k] += num;
				}
			}

			let finalHTML = "";
			let column1 = document.createElement('div');
			let column2 = document.createElement('div');
			column1.className = "card-column";
			column2.className = "card-column";
			for (const section_name in card_categories) {
				let section_html = card_categories[section_name];
				if (section_html == "") {
					continue;
				}
				let section_name_capitalized = section_name[0].toUpperCase() + section_name.substring(1, section_name.length);
				let card_column = column1;
				if (section_name == "land" || section_name == "sideboard" || section_name == "sanctum") {
					card_column = column2;
				}

				// card_column.innerHTML += `<div class="${section_name} card-type-section" id="${section_name}">
				//      <span class="${section_name}-header card-type-header" id="${section_name}-header">${section_name_capitalized} (${total_copies[section_name]})</span>
				// <br>
				// ${section_html}
				// </div><br>`;
				let section_container = document.createElement('div');
				let section_header = document.createElement('span');
				section_header.className = "card-type-header";
				section_header.innerText = section_name_capitalized + " (" + total_copies[section_name] + ")";
				let line_break = document.createElement('br');
				let line_break2 = document.createElement('br');
				let cards_container = document.createElement('div');
				cards_container.innerHTML = section_html;
				for (const card_ele of cards_container.childNodes) {
					card_ele.onmouseover = function () {
						let card_name = card_ele.innerText.substring(card_ele.innerText.indexOf(" ") + 1, card_ele.innerText.length);
						let card_stats;
						for (const card2 of card_list_arrayified) {
							if (card2.card_name == card_name) {
								card_stats = card2;
								break;
							}
						}
						let deck_preview_card = document.getElementById("deck-preview-card");
						deck_preview_card.src = "/sets/" + card_stats.set + "-files/img/" + card_stats.number + (card_stats.shape.includes("token") ? "t_" : "_") + card_stats.card_name + ((card_stats.shape.includes("double")) ? "_front" : "") + "." + card_stats.image_type;
						//https://voyager-mtg.github.io/card?set=EXPT&num=44&name=Fyndhorn+Betrayer
						deck_preview_card.onclick = function () {
							window.location.href = `/card?set=${card_stats.set}&num=${card_stats.number}&name=${card_name.replaceAll(" ", "+")}`;
						}
					}
				}
				section_container.appendChild(section_header);
				section_container.appendChild(cards_container);
				section_container.appendChild(line_break);
				card_column.appendChild(section_container);
				// card_column.appendChild(line_break2);
			}

			let preview_card = document.createElement('img');
			preview_card.src = "/img/card_back.png";
			preview_card.id = "deck-preview-card";
			preview_card.className = "deck-preview-card";

			let decklist_container = document.createElement("div");
			decklist_container.appendChild(column1);
			decklist_container.appendChild(column2);
			decklist_container.appendChild(preview_card);
			decklist_container.className = "decklist-container";

			return decklist_container;
		}

		function makeGamesTab() {
			const content_container = document.createElement("div");
			content_container.className = "report-container";

			const opponents_container = document.createElement("div");
			opponents_container.className = "opponents-container popout";

			const scores_container = document.createElement("div");
			scores_container.className = "scores-container";

			const scores_number_container = document.createElement("div");
			scores_number_container.className = "scores-number-container";

			const p1_score_input = document.createElement("input");
			p1_score_input.className = "player-score-input popout";
			p1_score_input.id = "p1-score-input";

			const divider = document.createElement("div");
			divider.className = "report-score-divider text-bg";

			const p2_score_input = document.createElement("input");
			p2_score_input.className = "player-score-input popout";
			p2_score_input.id = "p2-score-input";

			const submit_scores_btn = document.createElement("button");
			submit_scores_btn.className = "report-scores-btn";
			submit_scores_btn.innerText = "Report";
			submit_scores_btn.onclick = async () => {
				const new_games = JSON.parse(event_data.games);
				const game = {};
				const player = user_data.username;
				const opponent = document.getElementsByClassName("active-opponent")[0].innerText;
				game[player] = ["unclaimed", document.getElementById("p1-score-input").value];
				game[opponent] = ["unclaimed", document.getElementById("p2-score-input").value];
				new_games.push(game);
				alert(`Game reported. Go to the runs tab to assign it to a run!`);
				await updateDoc(doc(db, "events", event), {
					games: JSON.stringify(new_games)
				});
				reload();
			}

			const username_ele = document.createElement("span");
			username_ele.className = "report-username text";
			username_ele.innerText = username;

			for (const player of Object.keys(JSON.parse(event_data.runs))) {
				if (player == user_data.username)
					continue;

				const opponent_container = document.createElement("div");
				opponent_container.className = "opponent-container";
				opponent_container.innerText = player;
				opponent_container.onclick = () => {
					Array.from(document.getElementsByClassName("opponent-container")).forEach(container => {
						container.className = container.innerText == player && !container.className.includes("active") ? "opponent-container active-opponent" : "opponent-container";
					});
				}

				opponents_container.appendChild(opponent_container);
			}

			scores_number_container.appendChild(p1_score_input);
			scores_number_container.appendChild(divider);
			scores_number_container.appendChild(p2_score_input);

			scores_container.appendChild(scores_number_container);
			scores_container.appendChild(submit_scores_btn);

			content_container.appendChild(username_ele);
			content_container.appendChild(scores_container);
			content_container.appendChild(opponents_container);

			document.getElementById("games").appendChild(content_container);
		}

		if (sessionid) {
			reload();
		}
	</script>
</body>

</html>