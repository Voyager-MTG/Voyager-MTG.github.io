<html>

<head>
	<title>TITLE</title>
	<link rel="icon" type="image/x-icon" href="/img/favicon.png">
	<link rel="stylesheet" href="/src/css/mana.css">
	<link rel="stylesheet" href="/src/css/header.css">
	<link rel="stylesheet" href="/src/css/theme.css">
	<link rel="stylesheet" href="/src/css/modal.css">
	<link rel="stylesheet" href="/src/css/img-container.css">
	<link rel="stylesheet" href="/src/css/pages/deck.css">
</head>
<body>
	<div class="header">
		<div class="search-grid">
			<a href="/"><img class="sg-logo" src="/img/banner.png"></a>
			<img class="sg-icon" src="/img/header/search.png">
			<input type="text" inputmode="search" placeholder="Search ..." name="search" id="search" spellcheck="false"
				autocomplete="off" autocorrect="off" spellcheck="false">
			<a href="/all-sets"><img src="/img/header/sets.png" class="sg-icon">Sets</a>
			<a href="/deckbuilder"><img src="/img/header/deck.png" class="sg-icon">Deckbuilder</a>
			<a onclick="randomCard()"><img src="/img/random.png" class="sg-icon">Random</a>
			<div class="community"><a href="/community" id="account-link"><img src="/img/header/community.png"
						class="sg-icon">Community<b>â®Ÿ</b></a>
				<div class="community-dropdown">
					<a href="/community?tab=users" class="community-dropdown-item"><img class="dropdown-icon"
							src="/img/header/community.png">Users</a>
					<a href="/community?tab=decks" class="community-dropdown-item"><img class="dropdown-icon"
							src="/img/header/deck.png">Decks</a>
					<a href="/community?tab=events" class="community-dropdown-item"><img class="dropdown-icon"
							src="/img/swords.png">Events</a>
					<a href="/community?tab=cards" class="community-dropdown-item"><img class="dropdown-icon"
							src="/img/header/sets.png">Cards</a>
				</div>
			</div>
			<a href="/settings" id="account-link"><img src="/img/header/settings.png" class="sg-icon"></a>
			<a href="/account" id="account-link"><img src="/img/header/account.png" class="sg-icon"></a>
		</div>
	</div>
	<div class="selects" id="selects">
		<select id="color-select" onchange="setGradient()">
		</select>
	</div>
	<div class="page-container">
		<h1 class="deck-name text" id="deck-name">Deck Name</h1>
		<span class="deck-author text" id="deck-author">by Unknown</span>
		<div class="deck-options">
			<button class="deck-button">Export <img class="deck-button-icon" src="/img/export-white.png"></button>
			<a id="editb"><button class="deck-button">Edit <img class="deck-button-icon" src="/img/edit.png"></button></a>
			<div class="deck-opt-section">
				<span class="deck-opt-label">Displayed as:</span>
				<select class="deck-opt-select" id="displayed-as">
					<option>Sorted by MV</option>
					<option>Text</option>
					<option>Grid</option>
				</select>
			</div>
		</div>
		<div class="deck-container" id="deck-container">

		</div>
	</div>
	<div id="modal-container">
		<div id="modal-content" class="popout">
			<span class="close"
				onclick="document.getElementById('modal-container').style.display = 'none';">&times;</span>
		</div>
	</div>
	<img id="hover-card" class="hover-card">
	<script src="/src/js/background.js"></script>
	<script src="/src/js/img-container-defs.js"></script>
	<script>

		modal = document.getElementById("modal-container");
		window.onclick = function (event) {
			if (event.target == modal) {
				document.getElementById('modal-container').style.display = 'none';
			}
		}

		document.getElementById("search").addEventListener("keypress", function (event) {
			if (event.key === "Enter") {
				event.preventDefault();
				const url = new URL('search', window.location.origin);
				url.searchParams.append('search', document.getElementById("search").value);
				window.location.href = url;
			}
		});
		function randomCard() {
			let i = Math.floor(Math.random() * (card_list_arrayified.length + 1));
			let random_card = card_list_arrayified[i];

			const url = new URL('card', window.location.origin);
			const params = {
				set: random_card.set,
				num: random_card.number,
				name: random_card.card_name
			}
			for (const key in params) {
				url.searchParams.append(key, params[key]);
			}

			window.location.href = url;
		}
	</script>
	<script type="module">
		// Import the functions you need from the SDKs you need
		import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js";
		import { setDoc, addDoc, updateDoc, doc, collection, getFirestore, query, where, getDocs, getDoc } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js";
		// TODO: Add SDKs for Firebase products that you want to use
		// https://firebase.google.com/docs/web/setup#available-libraries

		// Your web app's Firebase configuration
		// For Firebase JS SDK v7.20.0 and later, measurementId is optional
		const firebaseConfig = {
			apiKey: "AIzaSyCPurnKVn2caCn3L-gKF2tMFwWur73YAuw",
			authDomain: "voyager-78e30.firebaseapp.com",
			projectId: "voyager-78e30",
			storageBucket: "voyager-78e30.firebasestorage.app",
			messagingSenderId: "411191248476",
			appId: "1:411191248476:web:591349be169d823e5f8899",
			measurementId: "G-TQ1L48F25M"
		};

		// Initialize Firebase
		const app = initializeApp(firebaseConfig);
		const db = getFirestore(app);
		let username = "";
		let password = "";
		let sessionid = localStorage.getItem('settings.session');
		let decks = {};
		const events = ["GP1", "League"];
		let user_data;

		const group_cards = false;
		const card_spacing = 38;
		const card_height = 300;

		document.body.style.setProperty("--card-height", card_height + "px");
		document.body.style.setProperty("--card-spacing", card_spacing + "px");

		if (sessionid) {
			await getDoc(doc(db, 'sessions', sessionid)).then(docSnap => {
				let data = docSnap.data();
				username = data.username;
				password = data.password;
			});

			await getDoc(doc(db, 'users', username)).then(docSnap => {
				let data = docSnap.data();
				user_data = data;
			});
		}

		let card_list;
		let deck_author;

		await fetch('/lists/all-cards.json')
				.then(response => response.json())
				.then(json => {
					card_list = json;
				}).catch(error => console.error('Error:', error));

		let card_list_arrayified = card_list.cards;

		async function reload() {
			const urlParams = new URLSearchParams(window.location.search);

			if (urlParams.get('deck') != null) { // check if deck exists
				if (urlParams.get('deck').includes(';')) { // check if deck has the ';' (for deck names)
					let splitted = urlParams.get('deck').split(';'); // get the deck name and text by splitting
					deck_author = "Unknown";
					loadDeck(atob(splitted[1]), splitted[0]);
				}

				if (urlParams.get("deck").includes("-") && !urlParams.get("deck").includes(";")) {
					const splitted = urlParams.get('deck').split('-');
					const deck_user = splitted[0];
					deck_author = deck_user;
					const deck_name = splitted[1];
					await getDoc(doc(db, 'users', deck_user)).then(docSnap => {
						let data2 = docSnap.data();
						let decks = data2.decks;
						for (const deck of decks) {
							if (deck.name == deck_name) {
								let text = atob(deck.url.split(";")[1].split("&")[0]);
								loadDeck(text, deck.name);
								window.fireimport = true;
								break;
							}
						}
					});
				}
			}

			if (urlParams.get('edeck') != null) { // check if deck exists
				const splitted = urlParams.get('edeck').split('-');
				const deck_event = splitted[0];
				const deck_user = splitted[1];
				deck_author = deck_user;
				await getDoc(doc(db, 'events', deck_event)).then(docSnap => {
					let data3 = docSnap.data();
					let decks = data3.decks;
					for (const user in decks) {
						if (user == deck_user) {
							let deck = decks[user];
							let text = atob(deck.url.split(";")[1].split("&")[0]);
							loadDeck(text, deck.name);
							window.fireimport = true;
							break;
						}
					}
				});
			}
		}

		function makeMaps(deck, name) {
			document.getElementById("deck-name").innerText = name;
			document.getElementById("deck-author").innerText = "by " + deck_author;
			document.getElementById("editb").href = "/deckbuilder" + window.location.search;

			let sideboard = [];
			let sanctum = [];
			let sb_cards = false;
			let sc_cards = false;

			const lines = deck.split('\n');

			let deck_map = new Map();
			let land_map = new Map();
			let sb_map = new Map();
			let sc_map = new Map();

			for (const line of lines) {
				if (line == 'sideboard' || line == '') // '' for Draftmancer files
				{
					sb_cards = true;
				}
				else if (line == 'sanctum' || (sb_cards && line == '')) // '' for Draftmancer files
				{
					sc_cards = true;
					sb_cards = false;
				}
				else if (!sb_cards && !sc_cards) {
					// get the count and card name
					let count = parseInt(line.substring(0, line.indexOf(' ')));
					let card_name = line.substring(line.indexOf(' ') + 1);
					
					if (deck_map.has(card_name)) // if the deck has card name, add the new value, if it doesnt, set the value to stop keyerrors
					{
						deck_map.set(card_name, deck_map.get(card_name) + count);
					}
					else {
						deck_map.set(card_name, count);
					}
				}
				else if (sb_cards) // sideboard cards, do the same thing but with sb_map
				{
					let count = parseInt(line.substring(0, line.indexOf(' ')));
					let card_name = line.substring(line.indexOf(' ') + 1);

					if (sb_map.has(card_name)) {
						sb_map.set(card_name, sb_map.get(card_name) + count);
					}
					else {
						sb_map.set(card_name, count);
					}
				} else if (sc_cards) // sanctum cards, do the same thing but with sc_map
				{
					let count = parseInt(line.substring(0, line.indexOf(' ')));
					let card_name = line.substring(line.indexOf(' ') + 1);

					if (sc_map.has(card_name)) {
						sc_map.set(card_name, sc_map.get(card_name) + count);
					}
					else {
						sc_map.set(card_name, count);
					}
				}
			}

			const deck_done = [];
			const sb_done = [];
			const sc_done = [];

			for (const card of card_list_arrayified) {
				if (deck_map.has(card.card_name) && !deck_done.includes(card.card_name)) {
					deck_done.push(card.card_name);
					deck_map.set(card.card_name, [card, deck_map.get(card.card_name)]);
				}

				if (sb_map.has(card.card_name) && !sb_done.includes(card.card_name)) {
					sb_done.push(card.card_name);
					sb_map.set(card.card_name, [card, sb_map.get(card.card_name)]);
				}

				if (sc_map.has(card.card_name) && !sc_done.includes(card.card_name)) {
					sc_done.push(card.card_name);
					sc_map.set(card.card_name, [card, sc_map.get(card.card_name)]);
				}
			}

			return [deck_map, sb_map, sc_map];
		}

		function convertToMV(cost) {
			let mv = 0;

			const costTokens = cost.substring(1, cost.length - 1).replaceAll("}{", " ").split(' ');
			for (const token of costTokens) {
				if (isDecimal(token)) {
					mv += parseInt(token);
				}
				// 2brid
				else if (token.includes('2')) {
					mv += 2;
				}
				else if (token != "X" && token != "") {
					mv += 1;
				}
			}

			return mv;
		}

		function showCardHover(card_name, set = false, num = false) {
			// console.log(set, num);
			for (const card_stats of card_list_arrayified) {
				if (card_stats.card_name == card_name && (!set || card_stats.set == set) && (!num || card_stats.number == num)) {
					const src = "/sets/" + card_stats.set + "-files/img/" + card_stats.number + (card_stats.shape.includes("token") ? "t_" : "_") + card_stats.card_name + ((card_stats.shape.includes("double")) ? "_front" : "") + "." + card_stats.image_type;

					const hover_card = document.getElementById("hover-card");
					hover_card.style.display = "block";
					hover_card.src = src;
					return;
				}
			}
		}

		function moveCardHover(event) {
			document.getElementById("hover-card").style.left = event.pageX + "px";
			document.getElementById("hover-card").style.top = event.pageY - 350 + "px";
		}

		function hideCardHover() {
			document.getElementById("hover-card").style.display = "none";
		}

		function loadDeck(deck, name) {
			document.getElementById("deck-container").style.gridTemplateColumns = "repeat(10, 1fr)";

			const small_width = window.innerWidth < 1200;

			const card_width = window.innerWidth * 0.87 / 10 * (small_width ? 2 : 1);
			const card_height = card_width * 3.5 / 2.5;

			if (small_width) {
				document.getElementById("deck-container").style.gridTemplateColumns = "repeat(5, 1fr)";
			}
			
			document.body.style.setProperty("--card-height", card_height + "px");
			document.body.style.setProperty("--card-spacing", card_height / 8 + "px");

			const maps = makeMaps(deck, name);
			const deck_map = maps[0];
			const sb_map = maps[1];
			const sc_map = maps[2];

			console.log(sb_map, sc_map);

			const mv_list = ["0-1", "0-2", 1, 2, 3, 4, 5, "6+", "Sideboard", "Sanctum"];
			let mv0s = []; 
			for (const mv of mv_list) {
				const mv_container = document.createElement("div");
				mv_container.className = "mv-container";
				mv_container.id = `mv-${mv}`;

				const mv_label = document.createElement("span");
				mv_label.className = "mv-label text";
				mv_label.id = `mv-label-${mv}`;
				mv_label.innerText = mv;

				const mv_cards_container = document.createElement("div");
				mv_cards_container.className = "mv-cards-container";
				mv_cards_container.id = `mv-cards-${mv}`;

				mv_container.appendChild(mv_label);
				mv_container.appendChild(mv_cards_container);

				document.getElementById("deck-container").appendChild(mv_container);
			}

			deck_map.forEach((copies_obj, card_name, map) => {
				const copies = copies_obj[1];
				const card = copies_obj[0];

				const cardMv = convertToMV(card.cost);

				if (cardMv == 0) { 
					mv0s.push([card, copies]);
				} else if (cardMv >= 6) {
					for (let i = 0; i < copies; i++) { // onmouseover="showCardHover('${card_name}')" onmousemove="moveCardHover(event)" onmouseout="hideCardHover()"
						const img_container = buildImgContainer(card);

						img_container.onmouseover = () => {
							showCardHover(card.card_name);
						}

						img_container.onmousemove = (event) => {
							moveCardHover(event);
						}

						img_container.onmouseout = () => {
							hideCardHover();
						}

						document.getElementById("mv-cards-6+").appendChild(img_container);
					}
				} else {
					for (let i = 0; i < copies; i++) {
						const img_container = buildImgContainer(card);

						img_container.onmouseover = () => {
							showCardHover(card.card_name);
						}

						img_container.onmousemove = (event) => {
							moveCardHover(event);
						}

						img_container.onmouseout = () => {
							hideCardHover();
						}

						document.getElementById(`mv-cards-${cardMv}`).appendChild(img_container);
					}
				}
			});

			sb_map.forEach((copies_obj, card_name, map) => {
				const copies = copies_obj[1];
				const card = copies_obj[0];

				for (let i = 0; i < copies; i++) { // onmouseover="showCardHover('${card_name}')" onmousemove="moveCardHover(event)" onmouseout="hideCardHover()"
					const img_container = buildImgContainer(card);

					img_container.onmouseover = () => {
						showCardHover(card.card_name);
					}

					img_container.onmousemove = (event) => {
						moveCardHover(event);
					}

					img_container.onmouseout = () => {
						hideCardHover();
					}

					document.getElementById("mv-cards-Sideboard").appendChild(img_container);
				}				
			});

			sc_map.forEach((copies_obj, card_name, map) => {
				const copies = copies_obj[1];
				const card = copies_obj[0];

				for (let i = 0; i < copies; i++) { // onmouseover="showCardHover('${card_name}')" onmousemove="moveCardHover(event)" onmouseout="hideCardHover()"
					const img_container = buildImgContainer(card);

					img_container.onmouseover = () => {
						showCardHover(card.card_name);
					}

					img_container.onmousemove = (event) => {
						moveCardHover(event);
					}

					img_container.onmouseout = () => {
						hideCardHover();
					}

					document.getElementById("mv-cards-Sanctum").appendChild(img_container);
				}
			});

			let half = 0;
			let counter = 0;

			for (const l of mv0s) {
				const copies = l[1];

				for (let i = 0; i < copies; i++) {
					half += 0.5;
				}
			}

			half = Math.floor(half);

			for (const l of mv0s) {
				const card = l[0];
				const copies = l[1];

				for (let i = 0; i < copies; i++) {
					const img_container = buildImgContainer(card);

					img_container.onmouseover = () => {
						showCardHover(card.card_name);
					}

					img_container.onmousemove = (event) => {
						moveCardHover(event);
					}

					img_container.onmouseout = () => {
						hideCardHover();
					}
					
					document.getElementById(`mv-cards-0-${counter <= half ? '1' : '2'}`).appendChild(img_container);
					counter++;
				}
			}
		}

		function loadDeckOld(deck, name) {
			const maps = makeMaps(deck, name);
			const deck_map = maps[0];

			const indexes = {};
			let current_row = 0;
			let current_col = 0;

			let card_3copies = [];
			let card_2copies = [];
			let card_1copies = [];
			
			deck_map.forEach((copies_obj, card_name, map) => {
				const copies = copies_obj[1];
				const card = copies_obj[0];

				if (copies == 4) {
					if (current_col == 6) {
						current_row += 4;
						current_col = 0;
					}

					indexes[card_name] = [card, ...calculateIndexes4Copies(current_row, current_col)];
					current_col++;

				}
				
				if (copies == 3) {
					card_3copies.push(card);
				}
				
				if (copies == 2) {
					card_2copies.push(card);
				}
				
				if (copies == 1) {
					card_1copies.push(card);
				}
			});

			const pairs_3and1 = Math.min(card_3copies.length, card_1copies.length);

			for (let i = 0;  i < pairs_3and1; i++) {
				const card3 = card_3copies[0];
				const card1 = card_1copies[0];

				console.log(card1, card3, i, [...card_3copies]);

				if (current_col == 6) {
					current_row += 4;
					current_col = 0;
				}

				const calculated = calculateIndexes3and1Copies(current_row, current_col, card1, card3);
				
				indexes[card1.card_name] = calculated[0];
				indexes[card3.card_name] = calculated[1];

				card_3copies.splice(0, 1);
				card_1copies.splice(0, 1);

				current_col++;
			}

			const pairs_2and2 = Math.floor(card_2copies.length / 2);

			for (let i = 0;  i < pairs_2and2; i += 2) {
				const card3 = card_2copies[0];
				const card1 = card_2copies[1];

				if (current_col == 6) {
					current_row += 4;
					current_col = 0;
				}

				const calculated = calculateIndexes2pairCopies(current_row, current_col, card1, card3);
				
				indexes[card1.card_name] = calculated[0];
				indexes[card3.card_name] = calculated[1];

				card_2copies.splice(0, 1);
				card_2copies.splice(0, 1);

				current_col++;
			}

			const pairs_332 = Math.min(card_3copies.length / 2, card_2copies.length);

			for (let i = 0;  i < pairs_332; i++) {
				const card31 = card_3copies[0];
				const card32 = card_3copies[1];
				const card2 = card_2copies[0];

				if (current_col == 6) {
					current_row += 4;
					current_col = 0;
				}

				const calculated = calculateIndexes332Copies(current_row, current_col, card31, card32, card2);

				console.log(card31.card_name, card32.card_name, card2.card_name, calculated, card_3copies);
				console.log(current_row, current_col);
				
				indexes[card31.card_name] = calculated[0];
				indexes[card32.card_name] = calculated[1];
				indexes[card2.card_name] = calculated[2];

				card_3copies.splice(0, 1);
				card_3copies.splice(0, 1);
				card_2copies.splice(0, 1);

				current_col += 2;
				
				if (current_col == 7) {
					current_col = 1;
					current_row += 4;
				}
			}

			let unplaced = [...card_1copies, ...card_2copies, ...card_2copies, ...card_3copies, ...card_3copies, ...card_3copies];

			for (let i = 0;  i < unplaced.length; i++) {
				

				if (current_col == 6) {
					current_row += 4;
					current_col = 0;
				}

				const card = unplaced[i];

				if (!indexes[card.card_name]) {
					indexes[card.card_name] = [card, current_row * 6 + current_col];
				} else {
					indexes[card.card_name].push(current_row * 6 + current_col);
				}

				current_col++;
			} 

			console.log(indexes);

			const new_indexes = [];

			for (const card_name in indexes) {
				const card_locs = indexes[card_name].slice(1, indexes[card_name].length);
				const card = indexes[card_name][0];

				for (const index of card_locs) {
					new_indexes[index] = card;
				}
			}

			console.log(new_indexes);

			for (const card of new_indexes) {
				if(card) {
					document.getElementById("deck-container").appendChild(buildImgContainer(card));
				} else {
					document.getElementById("deck-container").appendChild(document.createElement("div"));
				}
			}
			/*

			for (const card of card_list_arrayified) {
				// for every card, if it's in the deck map, add it to the deck, then remove it from the deck map; repeat with the sideboard map
				if (deck_map.has(card.card_name)) {
					for (let i = 0; i < deck_map.get(card.card_name); i++) {
						document.getElementById("deck-container").appendChild(buildImgContainer(card));
					}
					deck_map.delete(card.card_name);
				}
			}

			for (const card of card_list_arrayified) {
				// for every card, if it's in the deck map, add it to the deck, then remove it from the deck map; repeat with the sideboard map
				if (land_map.has(card.card_name)) {
					for (let i = 0; i < land_map.get(card.card_name); i++) {
						document.getElementById("deck-container").appendChild(buildImgContainer(card));
					}
					land_map.delete(card.card_name);
				}
			}*/
		}

		function calculateIndexes4Copies(current_row, current_col) {
			return [current_row * 6 + current_col, (current_row + 1) * 6 + current_col, (current_row + 2) * 6 + current_col, (current_row + 3) * 6 + current_col];
		}

		function calculateIndexes3and1Copies(current_row, current_col, card1, card3) {
			return [[card1, current_row * 6 + current_col], [card3, (current_row + 1) * 6 + current_col, (current_row + 2) * 6 + current_col, (current_row + 3) * 6 + current_col]];
		}

		function calculateIndexes2pairCopies(current_row, current_col, card1, card2) {
			return [[card1, current_row * 6 + current_col, (current_row + 1) * 6 + current_col], [card2, (current_row + 2) * 6 + current_col, (current_row + 3) * 6 + current_col]];
		}

		function calculateIndexes332Copies(current_row, current_col, card31, card32, card2) {
			/*if (current_col == 5) {
				return [[card31, (current_row + 1) * 6 + current_col, (current_row + 2) * 6 + current_col, (current_row + 3) * 6 + current_col], [card32, (current_row + 5) * 6 + 1, (current_row + 6) * 6 + 1, (current_row + 7) * 6 + 1], [card2, current_row * 6 + 3 + current_col, (current_row + 4) * 6 + 5]];
			}*/

			console.log(current_row, current_col, current_row * 6 + current_col, 
					current_row * 6 + 1 + current_col);

			return [
				[card31, 
					(current_row + 1) * 6 + current_col, 
					(current_row + 2) * 6 + current_col, 
					(current_row + 3) * 6 + current_col
				], 
				[card32, 
					(current_row + 1) * 6 + current_col + 1, 
					(current_row + 2) * 6 + current_col + 1, 
					(current_row + 3) * 6 + current_col + 1
				], 
				[card2, 
					current_row * 6 + current_col, 
					current_row * 6 + 1 + current_col
				]
			];
		}

		reload();
	</script>
</body>

</html>