<html>

<head>
	<title>TITLE</title>
	<link rel="icon" type="image/x-icon" href="/img/favicon.png">
	<link rel="stylesheet" href="/src/css/mana.css">
	<link rel="stylesheet" href="/src/css/header.css">
	<link rel="stylesheet" href="/src/css/theme.css">
	<link rel="stylesheet" href="/src/css/modal.css">
	<link rel="stylesheet" href="/src/css/img-container.css">
	<link rel="stylesheet" href="/src/css/pages/deck.css">
</head>
<body>
	<div class="header">
		<div class="search-grid">
			<a href="/"><img class="sg-logo" src="/img/banner.png"></a>
			<img class="sg-icon" src="/img/header/search.png">
			<input type="text" inputmode="search" placeholder="Search ..." name="search" id="search" spellcheck="false"
				autocomplete="off" autocorrect="off" spellcheck="false">
			<a href="/all-sets"><img src="/img/header/sets.png" class="sg-icon">Sets</a>
			<a href="/deckbuilder"><img src="/img/header/deck.png" class="sg-icon">Deckbuilder</a>
			<a onclick="randomCard()"><img src="/img/random.png" class="sg-icon">Random</a>
			<div class="community"><a href="/community" id="account-link"><img src="/img/header/community.png"
						class="sg-icon">Community<b>⮟</b></a>
				<div class="community-dropdown">
					<a href="/community?tab=users" class="community-dropdown-item"><img class="dropdown-icon"
							src="/img/header/community.png">Users</a>
					<a href="/community?tab=decks" class="community-dropdown-item"><img class="dropdown-icon"
							src="/img/header/deck.png">Decks</a>
					<a href="/community?tab=events" class="community-dropdown-item"><img class="dropdown-icon"
							src="/img/swords.png">Events</a>
					<a href="/community?tab=cards" class="community-dropdown-item"><img class="dropdown-icon"
							src="/img/header/sets.png">Cards</a>
				</div>
			</div>
			<a href="/settings" id="account-link"><img src="/img/header/settings.png" class="sg-icon"></a>
			<a href="/account" id="account-link"><img src="/img/header/account.png" class="sg-icon"></a>
		</div>
	</div>
	<div class="selects" id="selects">
		<select id="color-select" onchange="setGradient()">
		</select>
	</div>
	<div class="page-container">
		<h1 class="deck-name text" id="deck-name">Deck Name</h1>
		<span class="deck-author text" id="deck-author">by Unknown</span>
		<div class="deck-options">
			<button class="deck-button" onclick="openExportModal()">Export <img class="deck-button-icon" src="/img/export-white.png"></button>
			<a id="editb"><button class="deck-button">Edit <img class="deck-button-icon" src="/img/edit.png"></button></a>
			<div class="deck-opt-section">
				<span class="deck-opt-label">Displayed as:</span>
				<select class="deck-opt-select" id="displayed-as">
					<option value="vstacks">Visual Stacks</option>
					<option value="nstacks">Numbered Stacks</option>
					<option value="text">Text</option>
					<!-- <option>Text</option>
					<option>Grid</option> -->
				</select>
			</div>
			<div class="deck-opt-section">
				<span class="deck-opt-label">Sorted by:</span>
				<select class="deck-opt-select" id="sort-type">
					<option value="mv">Mana Value</option>
					<option value="cardtype">Card Type</option>
					<option value="color">Color</option>
					<!-- <option value="rarity">Rarity</option> -->
					<!-- <option>Text</option>
					<option>Grid</option> -->
				</select>
			</div>
			<div class="deck-opt-section">
				<span class="deck-opt-label">Card versions:</span>
				<select class="deck-opt-select" id="format-select">
					<option value="old">Deck Last Modified</option>
					<option value="current">Current Versions</option>
				</select>
			</div>
		</div>
		<div class="deck-container" id="deck-container">

		</div>
	</div>
	<div id="modal-container">
		<div id="modal-content" class="popout">
			<span class="close"
				onclick="document.getElementById('modal-container').style.display = 'none';">&times;</span>
		</div>
	</div>
	<div id="hover-card" class="hover-card">
	<script src="/src/js/background.js"></script>
	<script src="/src/js/img-container-defs.js"></script>
	<script>

		modal = document.getElementById("modal-container");
		window.onclick = function (event) {
			if (event.target == modal) {
				document.getElementById('modal-container').style.display = 'none';
			}
		}

		document.getElementById("search").addEventListener("keypress", function (event) {
			if (event.key === "Enter") {
				event.preventDefault();
				const url = new URL('search', window.location.origin);
				url.searchParams.append('search', document.getElementById("search").value);
				window.location.href = url;
			}
		});
		function randomCard() {
			let i = Math.floor(Math.random() * (card_list_arrayified.length + 1));
			let random_card = card_list_arrayified[i];

			const url = new URL('card', window.location.origin);
			const params = {
				set: random_card.set,
				num: random_card.number,
				name: random_card.card_name
			}
			for (const key in params) {
				url.searchParams.append(key, params[key]);
			}

			window.location.href = url;
		}

		function exportButtonHtml(name, func, img = false) {
			const button = document.createElement("span");
			button.className = "export-modal-button";
			button.innerText = name;

			button.onclick = func;

			if (img) {
				const btn_img = document.createElement("img");
				btn_img.className = "export-icon";
				btn_img.src = img;
				button.appendChild(btn_img);
			}

			return button;
		}

		// jumphere

		function openExportModal() {
			const deck = window.deck;
			const sideboard = window.sideboard;
			const sanctum = window.sanctum;

			document.getElementById("modal-content").innerHTML = `<span class="close" onclick="closeModal()">&times;</span>`;
			let modalContent = document.createElement("div");
			modalContent.appendChild(exportButtonHtml("Deck URL", function () {
				navigator.clipboard.writeText(`https://voyager-mtg.github.io/deck?deck=${encodeURIComponent(document.getElementById("deck-name").innerText) + ';' + btoa(generateDeckText(true, true))}&main=${deck.length}&side=${sideboard.length}&sanctum=${sanctum.length}`); // write the url + ?deck= + the name with spaces replaced + ; + base64 encoded deck text + &main = deck count + &side= + sideboard count + &sanctum= + sanctum count
				openModal('<span class="close" onclick="closeModal()">&times;</span>' + "Url copied to clipboard"); // open the modal notifying the user
			}, "/img/copy-white.png"));

			modalContent.appendChild(exportButtonHtml("Decklist", function () {
				navigator.clipboard.writeText(generateDeckText()); // copy the deck text to clipboard
				document.getElementById("file-menu").value = "default"; // set the dropdown back
				openModal('<span class="close" onclick="closeModal()">&times;</span>' + "Decklist copied to clipboard"); // open the modal to notify the user
			}, "/img/copy-white.png"));

			modalContent.appendChild(exportButtonHtml("Discord Message", function () {
				navigator.clipboard.writeText(`# [${document.getElementById("deck-name").value}](https://voyager-mtg.github.io/deck?deck=${encodeURIComponent(document.getElementById("deck-name").innerText) + ';' + btoa(generateDeckText())}&main=${deck.length}&side=${sideboard.length}&sanctum=${sanctum.length})\n\`\`\`${generateDeckText()}\`\`\``); // CURSED
				document.getElementById("file-menu").value = "default";
				openModal('<span class="close" onclick="closeModal()">&times;</span>' + "Discord message copied to clipboard"); // open the modal to notify the user
			}, "/img/copy-white.png"));

			modalContent.appendChild(exportButtonHtml("Draftmancer", exportDraftmancer, "/img/download.png"));
			modalContent.appendChild(exportButtonHtml(".txt file", function () {
				exportFile("export-txt");
			}, "/img/download.png"));

			modalContent.appendChild(exportButtonHtml(".dek file", function () {
				exportFile("export-dek");
			}, "/img/download.png"));

			modalContent.appendChild(exportButtonHtml("Cockatrice (.cod)", function () {
				exportFile("export-cod");
			}, "/img/download.png"));

			document.getElementById("modal-container").style.display = "block";
			document.getElementById("modal-content").appendChild(modalContent);
		}

		function generateDeckText(seperate_sanctum = true, set_info = false) {
			const deck = window.deck;
			const sideboard = window.sideboard;
			const sanctum = window.sanctum;


			let deck_text = "";
			let map = new Map([]);

			for (const card of deck) {
				if (map.has(card)) {
					map.set(card, map.get(card) + 1);
				}
				else {
					map.set(card, 1);
				}
			}

			for (const card_map of Array.from(map.keys())) {
				console.log(set_info, (set_info ? ` (${JSON.parse(card_map).set}) ${JSON.parse(card_map).number}` : ""));
				deck_text += map.get(card_map) + " " + (JSON.parse(card_map).card_name) + (set_info ? ` (${JSON.parse(card_map).set}) ${JSON.parse(card_map).number}` : "") + "\n";
			}

			if (sideboard.length != 0 || (sanctum.length != 0 && !seperate_sanctum)) {
				deck_text += "sideboard\n";
				map = new Map([]);

				for (const card of sideboard) {
					if (map.has(card)) {
						map.set(card, map.get(card) + 1);
					}
					else {
						map.set(card, 1);
					}
				}

				if (!seperate_sanctum) {
					for (const card of sanctum) {
						if (map.has(card)) {
							map.set(card, map.get(card) + 1);
						}
						else {
							map.set(card, 1);
						}
					}
				}

				for (const card_map of Array.from(map.keys())) {
					deck_text += map.get(card_map) + " " + (JSON.parse(card_map).card_name) + (set_info ? ` (${JSON.parse(card_map).set}) ${JSON.parse(card_map).number}` : "") + "\n";
				}
			}

			if (seperate_sanctum && sanctum.length != 0) {
				deck_text += "sanctum\n";
				map = new Map([]);

				for (const card of sanctum) {
					if (map.has(card)) {
						map.set(card, map.get(card) + 1);
					}
					else {
						map.set(card, 1);
					}
				}

				for (const card_map of Array.from(map.keys())) {
					deck_text += map.get(card_map) + " " + (JSON.parse(card_map).card_name) + (set_info ? ` (${JSON.parse(card_map).set}) ${JSON.parse(card_map).number}` : "") + "\n";
				}
			}

			return deck_text;
		}


		async function exportDraftmancer() {
			const deck = window.deck;
			const sideboard = window.sideboard;
			const sanctum = window.sanctum;

			let output_text = "";
			let cards = new Map();


			for (const card of deck) {
				const c = JSON.parse(card);
				if (cards.has(c.card_name)) {
					cards.get(c.card_name).count += 1;
				}
				else {
					cards.set(c.card_name, { ...c, count: 1 });
				}
			}

			const URLDomain = window.location.href.split("/deckbuilder")[0]; // FIXME: Shouldn't be hardcoded.

			// 			let slots = ''; // disabled slots for now

			if (localStorage.getItem('settings.exportcollleague') == "On") {
				slots = { common: 8, uncommon: 5, rare: 2 };
			} else if (localStorage.getItem('settings.exportcube') == "On") {
				slots = { rare: 15 };
			} else {
				slots = { rare: 1, uncommon: 3, common: 10 };
			}

			// 			output_text += `[Settings]
			// {
			//   "layouts": {
			//     "default": {
			//       "weight": 1,
			//       "slots": {
			// 		${slots}
			//       }
			// 	}
			//   }
			// }
			// `;
			output_text += "[CustomCards]\n[\n";
			for (const c of cards.values()) {
				const img_url = URLDomain + "/sets/" + c.set + "-files/img/" + c.number + "_" + c.card_name + ((c.shape.includes("double")) ? "_front" : "") + "." + c.image_type;
				output_text += "  {\n";
				output_text += `    "name": "${c.card_name}",\n`;
				if (c.cost)
					output_text += `    "mana_cost": "${convertManaCostForDraftmancer(c.cost)}",\n`;
				else
					output_text += `    "mana_cost": "",\n`;
				if (c.rarity)
					output_text += `    "rarity": "${c.rarity}",\n`;
				if (c.set)
					output_text += `    "set": "${c.set}",\n`;
				if (c.number)
					output_text += `    "collector_number": "${c.number}",\n`;
				if (c.type) {
					output_text += `    "type": "${c.type.split(" – ")[0]}",\n`;
					const subtypes = c.type.split(" – ")[1];
					if (subtypes)
						output_text += `    "subtypes": ["${subtypes.split(" ").join("", "")}"],\n`;
				}
				if (c.rules_text)
					output_text += `    "oracle_text": ${JSON.stringify(c.rules_text)},\n`;
				output_text += `    "image": "${img_url}"\n`;
				if (c.shape.includes("double")) {
					const back_url = URLDomain + "/sets/" + c.set + "-files/img/" + c.number + "_" + c.card_name + "_back" + "." + c.image_type;
					output_text += `,\n    "back": {`
					output_text += `      "name": "${c.card_name2}",\n`;
					if (c.cost2)
						output_text += `      "mana_cost": "${convertManaCostForDraftmancer(c.cost2)}",\n`;
					else
						output_text += `    "mana_cost": "",\n`;
					if (c.rarity2)
						output_text += `      "rarity": "${c.rarity2}",\n`;
					if (c.set2)
						output_text += `      "set": "${c.set2}",\n`;
					if (c.number2)
						output_text += `      "collector_number": "${c.number2}",\n`;
					if (c.type2) {
						output_text += `      "type": "${c.type2.split(" – ")[0]}",\n`;
						const subtypes = c.type2.split(" – ")[1];
						if (subtypes)
							output_text += `    "subtypes": ["${subtypes.split(" ").join("", "")}"],\n`;
					}
					if (c.rules_text2)
						output_text += `      "oracle_text": ${JSON.stringify(c.rules_text2)},\n`;
					output_text += `      "image": "${back_url}"`
					output_text += `    }\n`;
				}
				output_text += "  },";
			}
			output_text = output_text.substring(0, output_text.length - 1)
			output_text += "\n]\n";

			if (localStorage.getItem('settings.exportcube') == "on") {
				output_text += `[rare(15)]
`;
				for (const c of cards.values()) {
					output_text += `${c.count} ${c.card_name}
`;
				}
			} else {
				const rarities = [...(new Set([...cards.values().map(c => convertRarity(c))]))];

				for (const r of rarities) {
					output_text += `[${r}(${slots[r]})]
`;
					for (const c of cards.values()) {
						if (convertRarity(c) === r) {
							output_text += `\t${c.count} ${c.card_name}\n`;
						}
					}
				}
			}

			let downloadableLink = document.createElement('a');
			downloadableLink.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(output_text));
			downloadableLink.download = document.getElementById("deck-name").value + ".txt";
			document.body.appendChild(downloadableLink);
			downloadableLink.click();
			document.body.removeChild(downloadableLink);

			document.getElementById("file-menu").value = "default";

		}

		function convertRarity(c) {
			if (c.rarity == "mythic" || c.rarity == "special")
				return "rare";

			return c.rarity;
		}

		async function exportFile(export_as) {
			const deck = window.deck;
			const sideboard = window.sideboard;
			const sanctum = window.sanctum;

			let deck_text = "";
			let deck_name = document.getElementById("deck-name").value;
			let export_cod = (export_as == "export-cod");

			if (export_cod) {
				deck_text += `<?xml version="1.0" encoding="UTF-8"?>\n<cockatrice_deck version="1">\n\t<deckname>${deck_name}</deckname>\n\t<zone name="main">\n`;
			}

			let map = new Map([]);
			for (const card of deck) {
				if (map.has(card)) {
					map.set(card, map.get(card) + 1);
				}
				else {
					map.set(card, 1);
				}
			}
			for (const card_map of Array.from(map.keys())) {
				let card_number = map.get(card_map);
				if (export_cod) {
					deck_text += `\t\t<card number="${card_number}" name="${JSON.parse(card_map).card_name}"/>\n`;
					continue; // continue instead of writing else
				}
				deck_text += card_number + " " + (export_as == "export-dek" ? card_map : JSON.parse(card_map).card_name + "\n");
			}
			if (sideboard.length != 0) {
				deck_text += export_cod ? '\t</zone>\n\t<zone name="side">\n' : "sideboard\n";
				map = new Map([]);
				for (const card of sideboard) {
					if (map.has(card)) {
						map.set(card, map.get(card) + 1);
					}
					else {
						map.set(card, 1);
					}
				}
				for (const card of sanctum) {
					if (map.has(card)) {
						map.set(card, map.get(card) + 1);
					}
					else {
						map.set(card, 1);
					}
				}
				for (const card_map of Array.from(map.keys())) {
					let card_number = map.get(card_map);
					if (export_cod) {
						deck_text += `\t\t<card number="${card_number}" name="${JSON.parse(card_map).card_name}"/>\n`;
						continue; // continue instead of writing else
					}
					deck_text += card_number + " " + (export_as == "export-dek" ? card_map : JSON.parse(card_map).card_name + "\n");
				}
			}

			if (export_cod) {
				deck_text += "\t</zone>\n</cockatrice_deck>";
			}

			let downloadableLink = document.createElement('a');
			downloadableLink.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(deck_text));
			downloadableLink.download = deck_name + ("." + export_as.split("-")[1]);
			document.body.appendChild(downloadableLink);
			downloadableLink.click();
			document.body.removeChild(downloadableLink);

			document.getElementById("file-menu").value = "default";
		}

		function openModal(html) {
			document.getElementById("modal-container").style.display = "block";
			document.getElementById("modal-content").innerHTML = html;
		}
	</script>
	<script type="module">
		// Import the functions you need from the SDKs you need
		import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js";
		import { setDoc, addDoc, updateDoc, doc, collection, getFirestore, query, where, getDocs, getDoc } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js";
		// TODO: Add SDKs for Firebase products that you want to use
		// https://firebase.google.com/docs/web/setup#available-libraries

		// Your web app's Firebase configuration
		// For Firebase JS SDK v7.20.0 and later, measurementId is optional
		const firebaseConfig = {
			apiKey: "AIzaSyCPurnKVn2caCn3L-gKF2tMFwWur73YAuw",
			authDomain: "voyager-78e30.firebaseapp.com",
			projectId: "voyager-78e30",
			storageBucket: "voyager-78e30.firebasestorage.app",
			messagingSenderId: "411191248476",
			appId: "1:411191248476:web:591349be169d823e5f8899",
			measurementId: "G-TQ1L48F25M"
		};

		// Initialize Firebase
		const app = initializeApp(firebaseConfig);
		const db = getFirestore(app);
		let username = "";
		let password = "";
		let sessionid = localStorage.getItem('settings.session');
		let decks = {};
		const events = ["GP1", "League"];
		let user_data;

		const group_cards = false;
		const card_spacing = 38;
		const card_height = 300;

		document.body.style.setProperty("--card-height", card_height + "px");
		document.body.style.setProperty("--card-spacing", card_spacing + "px");

		if (sessionid) {
			await getDoc(doc(db, 'sessions', sessionid)).then(docSnap => {
				let data = docSnap.data();
				username = data.username;
				password = data.password;
			});

			await getDoc(doc(db, 'users', username)).then(docSnap => {
				let data = docSnap.data();
				user_data = data;
			});
		}

		let card_list;
		let deck_author;

		await fetch('/lists/all-cards.json')
				.then(response => response.json())
				.then(json => {
					card_list = json;
				}).catch(error => console.error('Error:', error));

		let card_list_arrayified = card_list.cards; // default card list

		document.getElementById("sort-type").onchange = reload;
		document.getElementById("displayed-as").onchange = reload;
		document.getElementById("format-select").onchange = reload;

		async function reload() {
			document.getElementById("deck-container").innerHTML = "";

			const urlParams = new URLSearchParams(window.location.search);

			if (urlParams.get('deck') != null) { // check if deck exists
				if (urlParams.get('deck').includes(';')) { // check if deck has the ';' (for deck names)
					let splitted = urlParams.get('deck').split(';'); // get the deck name and text by splitting
					deck_author = "Unknown";
					await loadDeck(atob(splitted[1]), splitted[0]);
				}

				if (urlParams.get("deck").includes("-") && !urlParams.get("deck").includes(";")) {
					const splitted = urlParams.get('deck').split('-');
					const deck_user = splitted[0];
					deck_author = deck_user;
					const deck_name = splitted[1];
					await getDoc(doc(db, 'users', deck_user)).then(async docSnap => {
						let data2 = docSnap.data();
						let decks = data2.decks;
						for (const deck of decks) {
							if (deck.name == deck_name) {
								let text = atob(deck.url.split(";")[1].split("&")[0]);
								if (!deck.private) await loadDeck(text, deck.name, deck);
								window.fireimport = true;
								break;
							}
						}
					});
				}
			}

			if (urlParams.get('edeck') != null) { // check if deck exists
				const splitted = urlParams.get('edeck').split('-');
				const deck_event = splitted[0];
				const deck_user = splitted[1];
				deck_author = deck_user;
				await getDoc(doc(db, 'events', deck_event)).then(async docSnap => {
					let data3 = docSnap.data();
					let decks = data3.decks;
					for (const user in decks) {
						if (user == deck_user) {
							let deck = decks[user];
							let text = atob(deck.url.split(";")[1].split("&")[0]);
							if (!deck.private) await loadDeck(text, deck.name, deck);
							window.fireimport = true;
							break;
						}
					}
				});
			}
		}

		function makeMaps(deck, name) {
			document.getElementById("deck-name").innerText = name;
			document.getElementById("deck-author").innerText = "by " + deck_author;
			document.getElementById("editb").href = "/deckbuilder" + window.location.search;

			let _deck = [];
			let sideboard = [];
			let sanctum = [];
			let sb_cards = false;
			let sc_cards = false;

			const lines = deck.split('\n');

			let deck_map = new Map();
			let land_map = new Map();
			let sb_map = new Map();
			let sc_map = new Map();

			for (const line of lines) {
				if (line == 'sideboard' || line == '') // '' for Draftmancer files
				{
					sb_cards = true;
				}
				else if (line == 'sanctum' || (sb_cards && line == '')) // '' for Draftmancer files
				{
					sc_cards = true;
					sb_cards = false;
				}
				else if (!sb_cards && !sc_cards) {
					// get the count and card name
					let count = parseInt(line.substring(0, line.indexOf(' ')));
					let card_name = line.substring(line.indexOf(' ') + 1).split(" (")[0];
					
					if (deck_map.has(card_name)) // if the deck has card name, add the new value, if it doesnt, set the value to stop keyerrors
					{
						deck_map.set(card_name, deck_map.get(card_name) + count);
					}
					else {
						deck_map.set(card_name, count);
					}
				}
				else if (sb_cards) // sideboard cards, do the same thing but with sb_map
				{
					let count = parseInt(line.substring(0, line.indexOf(' ')));
					let card_name = line.substring(line.indexOf(' ') + 1).split(" (")[0];

					if (sb_map.has(card_name)) {
						sb_map.set(card_name, sb_map.get(card_name) + count);
					}
					else {
						sb_map.set(card_name, count);
					}
				} else if (sc_cards) // sanctum cards, do the same thing but with sc_map
				{
					let count = parseInt(line.substring(0, line.indexOf(' ')));
					let card_name = line.substring(line.indexOf(' ') + 1).split(" (")[0];

					if (sc_map.has(card_name)) {
						sc_map.set(card_name, sc_map.get(card_name) + count);
					}
					else {
						sc_map.set(card_name, count);
					}
				}
			}

			const deck_done = [];
			const sb_done = [];
			const sc_done = [];

			for (const card of card_list_arrayified) {
				if (card.type.includes("Token")) continue;
				if (deck_map.has(card.card_name) && !deck_done.includes(card.card_name)) {
					deck_done.push(card.card_name);
					deck_map.set(card.card_name, [card, deck_map.get(card.card_name)]);
				
					for (let i = 0; i < deck_map.get(card.card_name)[1]; i++) {
						_deck.push(JSON.stringify(card));
					}
				}

				if (sb_map.has(card.card_name) && !sb_done.includes(card.card_name)) {
					sb_done.push(card.card_name);
					sb_map.set(card.card_name, [card, sb_map.get(card.card_name)]);
					
					for (let i = 0; i < sb_map.get(card.card_name)[1]; i++) {
						sideboard.push(JSON.stringify(card));
					}
				}

				if (sc_map.has(card.card_name) && !sc_done.includes(card.card_name)) {
					sc_done.push(card.card_name);
					sc_map.set(card.card_name, [card, sc_map.get(card.card_name)]);
					
					for (let i = 0; i < sc_map.get(card.card_name)[1]; i++) {
						sanctum.push(JSON.stringify(card));
					}
				}
			}

			window.deck = _deck;
			window.sideboard = sideboard;
			window.sanctum = sanctum;

			return [deck_map, sb_map, sc_map];
		}

		function convertToMV(cost) {
			let mv = 0;

			const costTokens = cost.substring(1, cost.length - 1).replaceAll("}{", " ").split(' ');
			for (const token of costTokens) {
				if (isDecimal(token)) {
					mv += parseInt(token);
				}
				// 2brid
				else if (token.includes('2')) {
					mv += 2;
				}
				else if (token != "X" && token != "") {
					mv += 1;
				}
			}

			return mv;
		}

		function showCardHover(card) {
			const hover_card = document.getElementById("hover-card");
			hover_card.innerHTML = "";
			hover_card.style.display = "block";
			hover_card.appendChild(buildImgContainer(card, false, false, false, img_src));
		}

		function moveCardHover(event) {
			document.getElementById("hover-card").style.left = event.pageX + "px";
			document.getElementById("hover-card").style.top = event.pageY - 350 + "px";
		}

		function hideCardHover() {
			document.getElementById("hover-card").style.display = "none";
		}

		async function loadDeck(deck, name, deck_obj) {
			document.title = name;
			document.getElementById("deck-container").style.gridTemplateColumns = "repeat(10, 1fr)";

			const small_width = window.innerWidth < 1200;

			const card_width = window.innerWidth * 0.87 / 10 * (small_width ? 2 : 1);
			const card_height = card_width * 3.5 / 2.5;

			if (small_width) {
				document.getElementById("deck-container").style.gridTemplateColumns = "repeat(5, 1fr)";
			}
			
			document.body.style.setProperty("--card-height", card_height + "px");
			document.body.style.setProperty("--card-spacing", card_height / 8 + "px");

			await checkDeckFormat(deck_obj);

			const maps = makeMaps(deck, name);
			/*console.log("maps", maps);
			console.log("deck", deck);*/
			const sorted = sortDeck(maps);
			
			const view_map = {
				vstacks: loadDeckVStacks,
				nstacks: loadDeckNStacks,
				text: loadDeckText
			}

			view_map[document.getElementById("displayed-as").value](sorted);
		}

		async function checkDeckFormat(deck) {
			if (!deck) return;

			deck.last_modified = deck.last_modified || "31-05-2025";
			
			const deck_date = deck.last_modified.split(",")[0];
			const [ deck_day, deck_month, deck_year ] = deck_date.split("-").map(n => parseInt(n));
			let formats;

			await fetch('/data/formats.json')
				.then(response => response.json())
				.then(json => {
					formats = json;
				}).catch(error => console.error('Error:', error));

			
			if (document.getElementById("format-select").value == "current") {
				await setFormat(formats[formats.current]);
				return;
			}

			for (const [ format_date, format_hash ] of Object.entries(formats)) {
				const [ format_year, format_month, format_day ] = format_date.split("-").map(n => parseInt(n));
				
				console.log("f", format_year, format_month, format_day, "d", deck_year, deck_month, deck_day, "h", format_hash);

				if (format_year > deck_year) continue;
				if (format_month > deck_month) continue;
				if (format_day > deck_day) continue;

				await setFormat(format_hash);
			}
		}

		let img_src = "";

		async function setFormat(hash) {
			await fetch(`https://raw.githubusercontent.com/Voyager-MTG/Voyager-MTG.github.io/${hash}/lists/all-cards.json`)
				.then(response => response.json())
				.then(json => {
					card_list = json;
				}).catch(error => console.error('Error:', error));

			card_list_arrayified = card_list.cards;

			console.log(card_list_arrayified);

			img_src = `https://raw.githubusercontent.com/Voyager-MTG/Voyager-MTG.github.io/${hash}`;
		}

		function loadDeckText(sorted) {
			for (const group_id in sorted) {
				for (const [ card, copies ] of sorted[group_id]) {
					const card_container = document.createElement("div");
					card_container.className = "card-container";

					const card_name = document.createElement("span");
					card_name.className = "card-name";
					card_name.innerText = card.card_name;

					const card_copies = document.createElement("span");
					card_copies.className = "card-copies";
					card_copies.innerText = copies + "x";

					card_container.appendChild(card_copies);
					card_container.appendChild(card_name);

					card_container.onmouseover = () => {
						showCardHover(card);
					}

					card_container.onmousemove = (event) => {
						moveCardHover(event);
					}

					card_container.onmouseout = () => {
						hideCardHover();
					}

					document.getElementById(`group-cards-${group_id}`).appendChild(card_container);
					
				}
			}
		}

		function loadDeckNStacks(sorted) {	
			document.body.style.setProperty("--card-spacing", card_height / 5 + "px");
			for (const group_id in sorted) {
				for (const [ card, copies ] of sorted[group_id]) {
					const img_container = buildImgContainer(card, false, false, false, img_src);

					img_container.onmouseover = () => {
						showCardHover(card);
					}

					img_container.onmousemove = (event) => {
						moveCardHover(event);
					}

					img_container.onmouseout = () => {
						hideCardHover();
					}

					const copies_container = document.createElement("div");
					copies_container.className = "copies-indicator";
					copies_container.innerText = copies;

					if (copies != 1) img_container.appendChild(copies_container);

					document.getElementById(`group-cards-${group_id}`).appendChild(img_container);
					
				}
			}
		}

		function loadDeckVStacks(sorted) {	
			for (const group_id in sorted) {
				for (const [ card, copies ] of sorted[group_id]) {
					for (let i = 0; i < copies; i++) {
						const img_container = buildImgContainer(card, false, false, false, img_src);

						img_container.onmouseover = () => {
							showCardHover(card);
						}

						img_container.onmousemove = (event) => {
							moveCardHover(event);
						}

						img_container.onmouseout = () => {
							hideCardHover();
						}

						document.getElementById(`group-cards-${group_id}`).appendChild(img_container);
					}
				}
			}
		}

		function sortDeck(maps, duplicateCopies = false) {
			const [ deck_map, sb_map, sc_map ] = maps;

			const sort_mv = {
				l1:   ["Land/0", card => convertToMV(card.cost) == 0 ],
				l2:   ["Land/0", card => convertToMV(card.cost) == 0 ],
				mv1:  ["1",      card => convertToMV(card.cost) == 1 ],
				mv2:  ["2",      card => convertToMV(card.cost) == 2 ],
				mv3:  ["3",      card => convertToMV(card.cost) == 3 ],
				mv4:  ["4",      card => convertToMV(card.cost) == 4 ],
				mv5:  ["5",      card => convertToMV(card.cost) == 5 ],
				mv6:  ["6+",     card => convertToMV(card.cost) >= 6 ],

				sideboard: ["Sideboard", card => false],
				sanctum:   ["Sanctum",   card => false],

				callback: (groups) => {
					const half = Math.floor(groups.l1.length / 2) - 1;

					groups.l2 = [];

					for (let i = 0; i < half; i++) {
						const card = groups.l1[0];
						groups.l1.splice(0, 1);
						groups.l2.push(card);
					}
				}
			};

			const sort_card_type = {
				land:         ["Land"        , card => card.type.includes("Land"        )],
				creature:     ["Creature"    , card => card.type.includes("Creature"    )],
				enchantment:  ["Enchantment" , card => card.type.includes("Enchantment" )],
				artifact:     ["Artifact"    , card => card.type.includes("Artifact"    )],
				instant:      ["Instant"     , card => card.type.includes("Instant"     )],
				sorcery:      ["Sorcery"     , card => card.type.includes("Sorcery"     )],
				planeswalker: ["Planeswalker", card => card.type.includes("Planeswalker")],
				battle:       ["Battle"      , card => card.type.includes("Battle"      )],

				sideboard: ["Sideboard", card => false],
				sanctum:   ["Sanctum",   card => false],

				callback: (groups) => {}
			};

			const sort_color = {
				colorless:  ["Colorless",  card => card.color == ""  ],
				white:      ["White",      card => card.color == "W" ],
				blue:       ["Blue",       card => card.color == "U" ],
				black:      ["Black",      card => card.color == "B" ],
				red:        ["Red",        card => card.color == "R" ],
				green:      ["Green",      card => card.color == "G" ],
				silver:     ["Silver",     card => card.color == "I" ],
				multicolor: ["Multicolor", card => true],

				sideboard: ["Sideboard", card => false],
				sanctum:   ["Sanctum",   card => false],

				callback: (groups) => {}
			};

			const sort_map = {
				mv: sort_mv,
				cardtype: sort_card_type,
				color: sort_color
			};

			const sorted = {};
			const sort_type = sort_map[document.getElementById("sort-type").value];

			for (const group_id in sort_type) {
				if (group_id == "callback") continue;

				sorted[group_id] = [];
				const label = sort_type[group_id][0];

				const group_container = document.createElement("div");
				group_container.className = "group-container";
				group_container.id = `group-${group_id}`;

				const group_label = document.createElement("span");
				group_label.className = "group-label text";
				group_label.id = `group-label-${group_id}`;
				group_label.innerText = label;

				const group_cards_container = document.createElement("div");
				group_cards_container.className = "group-cards-container";
				group_cards_container.id = `group-cards-${group_id}`;

				group_container.appendChild(group_label);
				group_container.appendChild(group_cards_container);

				document.getElementById("deck-container").appendChild(group_container);
			}

			deck_map.forEach((copies_obj, card_name, map) => {
				const copies = copies_obj[1];
				const card = copies_obj[0];

				if (!card) return;
				
				for (const group_id in sort_type) {
					if (group_id == "callback") continue;
					const fn = sort_type[group_id][1];

					if (fn(card)) {
						sorted[group_id].push([card, copies]);
						break;
					}
				}
			});
			
			sb_map.forEach((copies_obj, card_name, map) => {
				const copies = copies_obj[1];
				const card = copies_obj[0];

				sorted.sideboard.push([card, copies]);
			});

			sc_map.forEach((copies_obj, card_name, map) => {
				const copies = copies_obj[1];
				const card = copies_obj[0];

				sorted.sanctum.push([card, copies]);
			});

			sort_type.callback(sorted);

			return sorted;
		}

		function loadDeckOld(decklist, name) {
			const maps = makeMaps(deck, name);
			const deck_map = maps[0];

			const indexes = {};
			let current_row = 0;
			let current_col = 0;

			let card_3copies = [];
			let card_2copies = [];
			let card_1copies = [];
			
			deck_map.forEach((copies_obj, card_name, map) => {
				const copies = copies_obj[1];
				const card = copies_obj[0];

				if (copies == 4) {
					if (current_col == 6) {
						current_row += 4;
						current_col = 0;
					}

					indexes[card_name] = [card, ...calculateIndexes4Copies(current_row, current_col)];
					current_col++;

				}
				
				if (copies == 3) {
					card_3copies.push(card);
				}
				
				if (copies == 2) {
					card_2copies.push(card);
				}
				
				if (copies == 1) {
					card_1copies.push(card);
				}
			});

			const pairs_3and1 = Math.min(card_3copies.length, card_1copies.length);

			for (let i = 0;  i < pairs_3and1; i++) {
				const card3 = card_3copies[0];
				const card1 = card_1copies[0];

				console.log(card1, card3, i, [...card_3copies]);

				if (current_col == 6) {
					current_row += 4;
					current_col = 0;
				}

				const calculated = calculateIndexes3and1Copies(current_row, current_col, card1, card3);
				
				indexes[card1.card_name] = calculated[0];
				indexes[card3.card_name] = calculated[1];

				card_3copies.splice(0, 1);
				card_1copies.splice(0, 1);

				current_col++;
			}

			const pairs_2and2 = Math.floor(card_2copies.length / 2);

			for (let i = 0;  i < pairs_2and2; i += 2) {
				const card3 = card_2copies[0];
				const card1 = card_2copies[1];

				if (current_col == 6) {
					current_row += 4;
					current_col = 0;
				}

				const calculated = calculateIndexes2pairCopies(current_row, current_col, card1, card3);
				
				indexes[card1.card_name] = calculated[0];
				indexes[card3.card_name] = calculated[1];

				card_2copies.splice(0, 1);
				card_2copies.splice(0, 1);

				current_col++;
			}

			const pairs_332 = Math.min(card_3copies.length / 2, card_2copies.length);

			for (let i = 0;  i < pairs_332; i++) {
				const card31 = card_3copies[0];
				const card32 = card_3copies[1];
				const card2 = card_2copies[0];

				if (current_col == 6) {
					current_row += 4;
					current_col = 0;
				}

				const calculated = calculateIndexes332Copies(current_row, current_col, card31, card32, card2);

				console.log(card31.card_name, card32.card_name, card2.card_name, calculated, card_3copies);
				console.log(current_row, current_col);
				
				indexes[card31.card_name] = calculated[0];
				indexes[card32.card_name] = calculated[1];
				indexes[card2.card_name] = calculated[2];

				card_3copies.splice(0, 1);
				card_3copies.splice(0, 1);
				card_2copies.splice(0, 1);

				current_col += 2;
				
				if (current_col == 7) {
					current_col = 1;
					current_row += 4;
				}
			}

			let unplaced = [...card_1copies, ...card_2copies, ...card_2copies, ...card_3copies, ...card_3copies, ...card_3copies];

			for (let i = 0;  i < unplaced.length; i++) {
				

				if (current_col == 6) {
					current_row += 4;
					current_col = 0;
				}

				const card = unplaced[i];

				if (!indexes[card.card_name]) {
					indexes[card.card_name] = [card, current_row * 6 + current_col];
				} else {
					indexes[card.card_name].push(current_row * 6 + current_col);
				}

				current_col++;
			} 

			console.log(indexes);

			const new_indexes = [];

			for (const card_name in indexes) {
				const card_locs = indexes[card_name].slice(1, indexes[card_name].length);
				const card = indexes[card_name][0];

				for (const index of card_locs) {
					new_indexes[index] = card;
				}
			}

			for (const card of new_indexes) {
				if(card) {
					document.getElementById("deck-container").appendChild(buildImgContainer(card, false, false, false, img_src));
				} else {
					document.getElementById("deck-container").appendChild(document.createElement("div"));
				}
			}
			/*

			for (const card of card_list_arrayified) {
				// for every card, if it's in the deck map, add it to the deck, then remove it from the deck map; repeat with the sideboard map
				if (deck_map.has(card.card_name)) {
					for (let i = 0; i < deck_map.get(card.card_name); i++) {
						document.getElementById("deck-container").appendChild(buildImgContainer(card));
					}
					deck_map.delete(card.card_name);
				}
			}

			for (const card of card_list_arrayified) {
				// for every card, if it's in the deck map, add it to the deck, then remove it from the deck map; repeat with the sideboard map
				if (land_map.has(card.card_name)) {
					for (let i = 0; i < land_map.get(card.card_name); i++) {
						document.getElementById("deck-container").appendChild(buildImgContainer(card));
					}
					land_map.delete(card.card_name);
				}
			}*/
		}

		function calculateIndexes4Copies(current_row, current_col) {
			return [current_row * 6 + current_col, (current_row + 1) * 6 + current_col, (current_row + 2) * 6 + current_col, (current_row + 3) * 6 + current_col];
		}

		function calculateIndexes3and1Copies(current_row, current_col, card1, card3) {
			return [[card1, current_row * 6 + current_col], [card3, (current_row + 1) * 6 + current_col, (current_row + 2) * 6 + current_col, (current_row + 3) * 6 + current_col]];
		}

		function calculateIndexes2pairCopies(current_row, current_col, card1, card2) {
			return [[card1, current_row * 6 + current_col, (current_row + 1) * 6 + current_col], [card2, (current_row + 2) * 6 + current_col, (current_row + 3) * 6 + current_col]];
		}

		function calculateIndexes332Copies(current_row, current_col, card31, card32, card2) {
			/*if (current_col == 5) {
				return [[card31, (current_row + 1) * 6 + current_col, (current_row + 2) * 6 + current_col, (current_row + 3) * 6 + current_col], [card32, (current_row + 5) * 6 + 1, (current_row + 6) * 6 + 1, (current_row + 7) * 6 + 1], [card2, current_row * 6 + 3 + current_col, (current_row + 4) * 6 + 5]];
			}*/

			console.log(current_row, current_col, current_row * 6 + current_col, 
					current_row * 6 + 1 + current_col);

			return [
				[card31, 
					(current_row + 1) * 6 + current_col, 
					(current_row + 2) * 6 + current_col, 
					(current_row + 3) * 6 + current_col
				], 
				[card32, 
					(current_row + 1) * 6 + current_col + 1, 
					(current_row + 2) * 6 + current_col + 1, 
					(current_row + 3) * 6 + current_col + 1
				], 
				[card2, 
					current_row * 6 + current_col, 
					current_row * 6 + 1 + current_col
				]
			];
		}

		reload();
	</script>
</body>

</html>